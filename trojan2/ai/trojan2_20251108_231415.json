{
  "timestamp": "20251108_231415",
  "model": "gpt-4-turbo",
  "prompt": "You are an expert hardware security engineer specializing in hardware Trojan design for security-critical systems.\n\nCONTEXT - OpenTitan Silicon Root of Trust:\nOpenTitan is an open-source silicon Root of Trust (RoT) that provides security primitives including:\n- Cryptographic accelerators (AES, SHA, RSA, ECDSA)\n- Secure boot and attestation\n- Key management and storage\n- Random number generation\n- Secure communication interfaces\n- Hardware security modules\n\nThe target is a high-value security component, so Trojans must be extremely stealthy.\n\nORIGINAL RTL CODE:\n```systemverilog\n// Copyright lowRISC contributors (OpenTitan project).\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n//\n// Description: csrng core module\n//\n\n\nmodule csrng_core import csrng_pkg::*; #(\n  parameter aes_pkg::sbox_impl_e SBoxImpl = aes_pkg::SBoxImplLut,\n  parameter int NumHwApps = 2,\n  parameter cs_keymgr_div_t RndCnstCsKeymgrDivNonProduction = CsKeymgrDivWidth'(0),\n  parameter cs_keymgr_div_t RndCnstCsKeymgrDivProduction = CsKeymgrDivWidth'(0)\n) (\n  input logic                                     clk_i,\n  input logic                                     rst_ni,\n\n  input  csrng_reg_pkg::csrng_reg2hw_t            reg2hw,\n  output csrng_reg_pkg::csrng_hw2reg_t            hw2reg,\n\n  // OTP Interface\n  input  prim_mubi_pkg::mubi8_t                   otp_en_csrng_sw_app_read_i,\n\n  // Lifecycle broadcast inputs\n  input  lc_ctrl_pkg::lc_tx_t                     lc_hw_debug_en_i,\n\n  // Entropy Interface\n  output entropy_src_pkg::entropy_src_hw_if_req_t entropy_src_hw_if_o,\n  input  entropy_src_pkg::entropy_src_hw_if_rsp_t entropy_src_hw_if_i,\n\n  // Entropy Interface\n  input  entropy_src_pkg::cs_aes_halt_req_t       cs_aes_halt_i,\n  output entropy_src_pkg::cs_aes_halt_rsp_t       cs_aes_halt_o,\n\n  // Application Interfaces\n  input  csrng_req_t [NumHwApps-1:0]              csrng_cmd_i,\n  output csrng_rsp_t [NumHwApps-1:0]              csrng_cmd_o,\n\n  // Alerts\n  output logic                                    recov_alert_test_o,\n  output logic                                    fatal_alert_test_o,\n  output logic                                    recov_alert_o,\n  output logic                                    fatal_alert_o,\n\n  // Interrupts\n  output logic                                    intr_cs_cmd_req_done_o,\n  output logic                                    intr_cs_entropy_req_o,\n  output logic                                    intr_cs_hw_inst_exc_o,\n  output logic                                    intr_cs_fatal_err_o\n);\n\n  import csrng_reg_pkg::*;\n\n  import prim_mubi_pkg::mubi4_t;\n  import prim_mubi_pkg::mubi4_test_true_strict;\n  import prim_mubi_pkg::mubi4_test_invalid;\n\n  localparam int unsigned ADataDepthClog = $clog2(CmdMaxClen) + 1;\n  localparam int unsigned CsEnableCopies = 51;\n  localparam int unsigned LcHwDebugCopies = 1;\n  localparam int unsigned Flag0Copies = 3;\n\n  // signals\n  // interrupt signals\n  logic                        event_cs_cmd_req_done;\n  logic                        event_cs_entropy_req;\n  logic                        event_cs_hw_inst_exc;\n  logic                        event_cs_fatal_err;\n  logic [CsEnableCopies-1:1]   cs_enable_fo;\n  logic [Flag0Copies-1:0]      flag0_fo;\n  logic                        acmd_flag0_pfa;\n  logic                        cs_enable_pfa;\n  logic                        sw_app_enable;\n  logic                        sw_app_enable_pfe;\n  logic                        sw_app_enable_pfa;\n  logic                        read_int_state;\n  logic                        read_int_state_pfe;\n  logic                        read_int_state_pfa;\n  logic                        fips_force_enable;\n  logic                        fips_force_enable_pfe;\n  logic                        fips_force_enable_pfa;\n  logic                        recov_alert_event;\n  logic                        acmd_avail;\n  logic                        acmd_sop;\n  logic                        acmd_mop;\n  logic                        acmd_eop;\n\n  logic                        cmd_blk_select;\n  logic                        gen_blk_select;\n\n  logic                        state_db_wr_vld;\n  logic                        state_db_wr_rdy;\n  csrng_core_data_t            state_db_wr_data;\n  csrng_cmd_sts_e              state_db_wr_sts;\n  csrng_state_t                state_db_rd_data;\n\n  logic [CmdBusWidth-1:0]      acmd_bus;\n  acmd_e                       acmd_hold;\n\n  logic [SeedLen-1:0]          packer_adata;\n  logic [ADataDepthClog-1:0]   packer_adata_depth;\n  logic                        packer_adata_pop;\n  logic                        packer_adata_clr;\n  logic [SeedLen-1:0]          seed_diversification;\n\n  logic                        cmd_entropy_req;\n  logic                        cmd_entropy_avail;\n  logic                        cmd_entropy_fips;\n  logic [SeedLen-1:0]          cmd_entropy;\n\n  logic                        ctr_drbg_cmd_rsp_vld;\n  logic                        ctr_drbg_cmd_rsp_rdy;\n  csrng_core_data_t            ctr_drbg_cmd_rsp_data;\n  logic                        ctr_drbg_cmd_rsp_glast;\n  logic                        ctr_drbg_cmd_rsp_wr;\n\n  logic                        ctr_drbg_cmd_req_vld;\n  logic                        ctr_drbg_cmd_req_rdy;\n  csrng_core_data_t            ctr_drbg_cmd_req_data;\n\n  logic                        ctr_drbg_gen_req_vld;\n  logic                        ctr_drbg_gen_req_rdy;\n\n  logic                        ctr_drbg_gen_rsp_vld;\n  logic                        ctr_drbg_gen_rsp_rdy;\n  csrng_core_data_t            ctr_drbg_gen_rsp_data;\n  logic [BlkLen-1:0]           ctr_drbg_gen_rsp_bits;\n  csrng_cmd_sts_e              ctr_drbg_gen_rsp_sts;\n\n  logic                        state_db_sts_ack;\n  csrng_cmd_sts_e              state_db_sts_sts;\n  logic [InstIdWidth-1:0]      state_db_sts_id;\n\n  logic                        acmd_accept;\n  logic                        main_sm_cmd_vld;\n  logic                        clr_adata_packer;\n\n  logic                        ctr_drbg_cmd_sfifo_rcstage_err_sum;\n  logic [2:0]                  ctr_drbg_cmd_sfifo_rcstage_err;\n  logic                        ctr_drbg_cmd_sfifo_keyvrc_err_sum;\n  logic [2:0]                  ctr_drbg_cmd_sfifo_keyvrc_err;\n  logic                        ctr_drbg_upd_sfifo_bencack_err_sum;\n  logic [2:0]                  ctr_drbg_upd_sfifo_bencack_err;\n  logic                        ctr_drbg_upd_sfifo_final_err_sum;\n  logic [2:0]                  ctr_drbg_upd_sfifo_final_err;\n  logic                        ctr_drbg_gen_sfifo_gbencack_err_sum;\n  logic [2:0]                  ctr_drbg_gen_sfifo_gbencack_err;\n  logic                        ctr_drbg_gen_sfifo_grcstage_err_sum;\n  logic [2:0]                  ctr_drbg_gen_sfifo_grcstage_err;\n  logic                        ctr_drbg_gen_sfifo_ggenreq_err_sum;\n  logic [2:0]                  ctr_drbg_gen_sfifo_ggenreq_err;\n  logic                        ctr_drbg_gen_sfifo_gadstage_err_sum;\n  logic [2:0]                  ctr_drbg_gen_sfifo_gadstage_err;\n  logic                        ctr_drbg_gen_sfifo_ggenbits_err_sum;\n  logic [2:0]                  ctr_drbg_gen_sfifo_ggenbits_err;\n  logic                        block_encrypt_sfifo_cmdid_err_sum;\n  logic [2:0]                  block_encrypt_sfifo_cmdid_err;\n  logic                        fifo_write_err_sum;\n  logic                        fifo_read_err_sum;\n  logic                        fifo_status_err_sum;\n\n  logic                        cmd_gen_cnt_err_sum;\n  logic                        cmd_stage_sm_err_sum;\n  logic                        main_sm_err_sum;\n  logic                        cs_main_sm_err;\n  logic [MainSmStateWidth-1:0] cs_main_sm_state;\n  logic                        drbg_gen_sm_err_sum;\n  logic                        drbg_gen_sm_err;\n  logic                        drbg_updbe_sm_err_sum;\n  logic                        drbg_updbe_sm_err;\n  logic                        drbg_updob_sm_err_sum;\n  logic                        drbg_updob_sm_err;\n  logic                        block_encrypt_sm_err_sum;\n  logic                        block_encrypt_sm_err;\n\n  // blk encrypt arbiter\n  // request path\n  logic                        upd_benc_req_vld;\n  logic                        upd_benc_req_rdy;\n  csrng_benc_data_t            upd_benc_req_data;\n\n  logic                        gen_benc_req_vld;\n  logic                        gen_benc_req_rdy;\n  csrng_benc_data_t            gen_benc_req_data;\n\n  logic                        block_encrypt_req_vld;\n  logic                        block_encrypt_req_rdy;\n  csrng_benc_data_t            block_encrypt_req_data;\n\n  // response path\n  logic                        upd_benc_rsp_vld;\n  logic                        upd_benc_rsp_rdy;\n\n  logic                        gen_benc_rsp_vld;\n  logic                        gen_benc_rsp_rdy;\n\n  logic                        block_encrypt_rsp_vld;\n  logic                        block_encrypt_rsp_rdy;\n  csrng_benc_data_t            block_encrypt_rsp_data;\n\n  // update unit arbiter\n  // request path\n  logic                        cmd_upd_req_vld;\n  logic                        cmd_upd_req_rdy;\n  csrng_upd_data_t             cmd_upd_req_data;\n\n  logic                        gen_upd_req_vld;\n  logic                        gen_upd_req_rdy;\n  csrng_upd_data_t             gen_upd_req_data;\n\n  logic                        upd_arb_req_vld;\n  logic                        upd_arb_req_rdy;\n  csrng_upd_data_t             upd_arb_req_data;\n\n  // response path\n  logic                        cmd_upd_rsp_vld;\n  logic                        cmd_upd_rsp_rdy;\n\n  logic                        gen_upd_rsp_vld;\n  logic                        gen_upd_rsp_rdy;\n\n  logic                        upd_rsp_vld;\n  logic                        upd_rsp_rdy;\n  csrng_upd_data_t             upd_rsp_data;\n\n\n  logic [2:0]                  cmd_stage_sfifo_cmd_err[NumApps];\n  logic [NumApps-1:0]          cmd_stage_sfifo_cmd_err_sum;\n  logic [NumApps-1:0]          cmd_stage_sfifo_cmd_err_wr;\n  logic [NumApps-1:0]          cmd_stage_sfifo_cmd_err_rd;\n  logic [NumApps-1:0]          cmd_stage_sfifo_cmd_err_st;\n  logic [2:0]                  cmd_stage_sfifo_genbits_err[NumApps];\n  logic [NumApps-1:0]          cmd_stage_sfifo_genbits_err_sum;\n  logic [NumApps-1:0]          cmd_stage_sfifo_genbits_err_wr;\n  logic [NumApps-1:0]          cmd_stage_sfifo_genbits_err_rd;\n  logic [NumApps-1:0]          cmd_stage_sfifo_genbits_err_st;\n  logic [NumApps-1:0]          cmd_gen_cnt_err;\n  logic [NumApps-1:0]          cmd_stage_sm_err;\n  logic                        ctr_drbg_upd_v_ctr_err;\n  logic                        ctr_drbg_gen_v_ctr_err;\n\n  logic [NumApps-1:0]          cmd_stage_vld;\n  logic [InstIdWidth-1:0]      cmd_stage_shid[NumApps];\n  logic [CmdBusWidth-1:0]      cmd_stage_bus[NumApps];\n  logic [NumApps-1:0]          cmd_stage_rdy;\n  logic [NumApps-1:0]          cmd_arb_req;\n  logic [NumApps-1:0]          cmd_arb_gnt;\n  logic [$clog2(NumApps)-1:0]  cmd_arb_idx;\n  logic [NumApps-1:0]          cmd_arb_sop;\n  logic [NumApps-1:0]          cmd_arb_mop;\n  logic [NumApps-1:0]          cmd_arb_eop;\n  logic [CmdBusWidth-1:0]      cmd_arb_bus[NumApps];\n  logic [NumApps-1:0]          cmd_core_ack;\n  csrng_cmd_sts_e [NumApps-1:0]cmd_core_ack_sts;\n  logic [NumApps-1:0]          cmd_stage_ack;\n  csrng_cmd_sts_e [NumApps-1:0]cmd_stage_ack_sts;\n  logic [NumApps-1:0]          genbits_core_vld;\n  logic [BlkLen-1:0]           genbits_core_bus[NumApps];\n  logic [NumApps-1:0]          genbits_core_fips;\n  logic [NumApps-1:0]          genbits_stage_vld;\n  logic [NumApps-1:0]          genbits_stage_fips;\n  logic [BlkLen-1:0]           genbits_stage_bus[NumApps];\n  logic [NumApps-1:0]          genbits_stage_rdy;\n  logic                        genbits_stage_vldo_sw;\n  logic                        genbits_stage_bus_rd_sw;\n  logic [31:0]                 genbits_stage_bus_sw;\n  logic                        genbits_stage_fips_sw;\n\n  logic [15:0]                 hw_exception_sts;\n  logic [LcHwDebugCopies-1:0]  lc_hw_debug_on_fo;\n  logic                        state_db_reg_read_en;\n\n  logic [30:0]                 err_code_test_bit;\n  logic                        ctr_drbg_upd_es_ack;\n  logic                        ctr_drbg_gen_es_ack;\n  logic                        block_encrypt_quiet;\n\n  logic                        cs_rdata_capt_vld;\n  logic                        cs_bus_cmp_alert;\n  logic                        cmd_rdy;\n  logic [NumApps-1:0]          invalid_cmd_seq_alert;\n  logic [NumApps-1:0]          invalid_acmd_alert;\n  logic [NumApps-1:0]          reseed_cnt_alert;\n  logic                        sw_sts_ack;\n  logic [1:0]                  otp_sw_app_read_en;\n\n  logic [NumApps-1:0][31:0]    reseed_counter;\n\n  prim_mubi_pkg::mubi8_t                [1:0] otp_sw_app_read_en_mubi;\n  prim_mubi_pkg::mubi4_t [CsEnableCopies-1:0] mubi_cs_enable_fanout;\n  prim_mubi_pkg::mubi4_t    [Flag0Copies-1:0] mubi_flag0_fanout;\n\n  // flops\n  acmd_e                acmd_q, acmd_d;\n  logic [3:0]           shid_q, shid_d;\n  logic                 gen_last_q, gen_last_d;\n  mubi4_t               flag0_q, flag0_d;\n  logic [NumAppsLg-1:0] cmd_arb_idx_q, cmd_arb_idx_d;\n  logic                 statedb_wr_select_q, statedb_wr_select_d;\n  logic                 genbits_stage_fips_sw_q, genbits_stage_fips_sw_d;\n  logic [CmdWidth-1:0]  cmd_req_ccmd_dly_q, cmd_req_ccmd_dly_d;\n  logic                 cs_aes_halt_q, cs_aes_halt_d;\n  logic [SeedLen-1:0]   entropy_src_seed_q, entropy_src_seed_d;\n  logic                 entropy_src_fips_q, entropy_src_fips_d;\n  logic [63:0]          cs_rdata_capt_q, cs_rdata_capt_d;\n  logic                 cs_rdata_capt_vld_q, cs_rdata_capt_vld_d;\n  logic                 sw_rdy_sts_q, sw_rdy_sts_d;\n  logic                 sw_sts_ack_q, sw_sts_ack_d;\n  logic [NumApps-1:0]   reseed_cnt_reached_q, reseed_cnt_reached_d;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      acmd_q                  <= INV;\n      shid_q                  <= '0;\n      gen_last_q              <= '0;\n      flag0_q                 <= prim_mubi_pkg::MuBi4False;\n      cmd_arb_idx_q           <= '0;\n      statedb_wr_select_q     <= '0;\n      genbits_stage_fips_sw_q <= '0;\n      cmd_req_ccmd_dly_q      <= '0;\n      cs_aes_halt_q           <= '0;\n      entropy_src_seed_q      <= '0;\n      entropy_src_fips_q      <= '0;\n      cs_rdata_capt_q         <= '0;\n      cs_rdata_capt_vld_q     <= '0;\n      sw_rdy_sts_q            <= '0;\n      sw_sts_ack_q            <= '0;\n      reseed_cnt_reached_q    <= '0;\n    end else begin\n      acmd_q                  <= acmd_d;\n      shid_q                  <= shid_d;\n      gen_last_q              <= gen_last_d;\n      flag0_q                 <= flag0_d;\n      cmd_arb_idx_q           <= cmd_arb_idx_d;\n      statedb_wr_select_q     <= statedb_wr_select_d;\n      genbits_stage_fips_sw_q <= genbits_stage_fips_sw_d;\n      cmd_req_ccmd_dly_q      <= cmd_req_ccmd_dly_d;\n      cs_aes_halt_q           <= cs_aes_halt_d;\n      entropy_src_seed_q      <= entropy_src_seed_d;\n      entropy_src_fips_q      <= entropy_src_fips_d;\n      cs_rdata_capt_q         <= cs_rdata_capt_d;\n      cs_rdata_capt_vld_q     <= cs_rdata_capt_vld_d;\n      sw_rdy_sts_q            <= sw_rdy_sts_d;\n      sw_sts_ack_q            <= sw_sts_ack_d;\n      reseed_cnt_reached_q    <= reseed_cnt_reached_d;\n    end\n  end\n\n  //--------------------------------------------\n  // instantiate interrupt hardware primitives\n  //--------------------------------------------\n  // All TLUL interrupts are collect in the section.\n\n  prim_intr_hw #(\n    .Width(1)\n  ) u_intr_hw_cs_cmd_req_done (\n    .clk_i                 (clk_i),\n    .rst_ni                (rst_ni),\n    .event_intr_i          (event_cs_cmd_req_done),\n    .reg2hw_intr_enable_q_i(reg2hw.intr_enable.cs_cmd_req_done.q),\n    .reg2hw_intr_test_q_i  (reg2hw.intr_test.cs_cmd_req_done.q),\n    .reg2hw_intr_test_qe_i (reg2hw.intr_test.cs_cmd_req_done.qe),\n    .reg2hw_intr_state_q_i (reg2hw.intr_state.cs_cmd_req_done.q),\n    .hw2reg_intr_state_de_o(hw2reg.intr_state.cs_cmd_req_done.de),\n    .hw2reg_intr_state_d_o (hw2reg.intr_state.cs_cmd_req_done.d),\n    .intr_o                (intr_cs_cmd_req_done_o)\n  );\n\n  prim_intr_hw #(\n    .Width(1)\n  ) u_intr_hw_cs_entropy_req (\n    .clk_i                 (clk_i),\n    .rst_ni                (rst_ni),\n    .event_intr_i          (event_cs_entropy_req),\n    .reg2hw_intr_enable_q_i(reg2hw.intr_enable.cs_entropy_req.q),\n    .reg2hw_intr_test_q_i  (reg2hw.intr_test.cs_entropy_req.q),\n    .reg2hw_intr_test_qe_i (reg2hw.intr_test.cs_entropy_req.qe),\n    .reg2hw_intr_state_q_i (reg2hw.intr_state.cs_entropy_req.q),\n    .hw2reg_intr_state_de_o(hw2reg.intr_state.cs_entropy_req.de),\n    .hw2reg_intr_state_d_o (hw2reg.intr_state.cs_entropy_req.d),\n    .intr_o                (intr_cs_entropy_req_o)\n  );\n\n  prim_intr_hw #(\n    .Width(1)\n  ) u_intr_hw_cs_hw_inst_exc (\n    .clk_i                 (clk_i),\n    .rst_ni                (rst_ni),\n    .event_intr_i          (event_cs_hw_inst_exc),\n    .reg2hw_intr_enable_q_i(reg2hw.intr_enable.cs_hw_inst_exc.q),\n    .reg2hw_intr_test_q_i  (reg2hw.intr_test.cs_hw_inst_exc.q),\n    .reg2hw_intr_test_qe_i (reg2hw.intr_test.cs_hw_inst_exc.qe),\n    .reg2hw_intr_state_q_i (reg2hw.intr_state.cs_hw_inst_exc.q),\n    .hw2reg_intr_state_de_o(hw2reg.intr_state.cs_hw_inst_exc.de),\n    .hw2reg_intr_state_d_o (hw2reg.intr_state.cs_hw_inst_exc.d),\n    .intr_o                (intr_cs_hw_inst_exc_o)\n  );\n\n  prim_intr_hw #(\n    .Width(1)\n  ) u_intr_hw_cs_fatal_err (\n    .clk_i                 (clk_i),\n    .rst_ni                (rst_ni),\n    .event_intr_i          (event_cs_fatal_err),\n    .reg2hw_intr_enable_q_i(reg2hw.intr_enable.cs_fatal_err.q),\n    .reg2hw_intr_test_q_i  (reg2hw.intr_test.cs_fatal_err.q),\n    .reg2hw_intr_test_qe_i (reg2hw.intr_test.cs_fatal_err.qe),\n    .reg2hw_intr_state_q_i (reg2hw.intr_state.cs_fatal_err.q),\n    .hw2reg_intr_state_de_o(hw2reg.intr_state.cs_fatal_err.de),\n    .hw2reg_intr_state_d_o (hw2reg.intr_state.cs_fatal_err.d),\n    .intr_o                (intr_cs_fatal_err_o)\n  );\n\n  // Counter and FSM errors are structural errors and are always active regardless of the\n  // functional state. main_sm_err_sum is not included here to prevent some tools from\n  // inferring combo loops. However, to include the state machine error for testing,\n  // we use the error code test bit (index 21) directly.\n  logic fatal_loc_events;\n  assign fatal_loc_events = cmd_gen_cnt_err_sum ||\n                            cmd_stage_sm_err_sum ||\n                            drbg_gen_sm_err_sum ||\n                            drbg_updbe_sm_err_sum ||\n                            drbg_updob_sm_err_sum ||\n                            block_encrypt_sm_err_sum ||\n                            err_code_test_bit[21];\n\n  // set the interrupt sources\n  assign event_cs_fatal_err = (cs_enable_fo[1]  && (\n         (|cmd_stage_sfifo_cmd_err_sum) ||\n         (|cmd_stage_sfifo_genbits_err_sum) ||\n         ctr_drbg_cmd_sfifo_rcstage_err_sum ||\n         ctr_drbg_cmd_sfifo_keyvrc_err_sum ||\n         ctr_drbg_upd_sfifo_bencack_err_sum ||\n         ctr_drbg_upd_sfifo_final_err_sum ||\n         ctr_drbg_gen_sfifo_gbencack_err_sum ||\n         ctr_drbg_gen_sfifo_grcstage_err_sum ||\n         ctr_drbg_gen_sfifo_ggenreq_err_sum ||\n         ctr_drbg_gen_sfifo_gadstage_err_sum ||\n         ctr_drbg_gen_sfifo_ggenbits_err_sum ||\n         block_encrypt_sfifo_cmdid_err_sum ||\n         fifo_write_err_sum ||\n         fifo_read_err_sum ||\n         fifo_status_err_sum)) ||\n         // errs not gated by cs_enable\n         main_sm_err_sum ||\n         fatal_loc_events;\n\n  // set fifo errors that are single instances of source\n  assign ctr_drbg_cmd_sfifo_rcstage_err_sum = (|ctr_drbg_cmd_sfifo_rcstage_err) ||\n         err_code_test_bit[3];\n  assign ctr_drbg_cmd_sfifo_keyvrc_err_sum = (|ctr_drbg_cmd_sfifo_keyvrc_err) ||\n         err_code_test_bit[4];\n  assign ctr_drbg_upd_sfifo_bencack_err_sum = (|ctr_drbg_upd_sfifo_bencack_err) ||\n         err_code_test_bit[7];\n  assign ctr_drbg_upd_sfifo_final_err_sum = (|ctr_drbg_upd_sfifo_final_err) ||\n         err_code_test_bit[9];\n  assign ctr_drbg_gen_sfifo_gbencack_err_sum = (|ctr_drbg_gen_sfifo_gbencack_err) ||\n         err_code_test_bit[10];\n  assign ctr_drbg_gen_sfifo_grcstage_err_sum = (|ctr_drbg_gen_sfifo_grcstage_err) ||\n         err_code_test_bit[11];\n  assign ctr_drbg_gen_sfifo_ggenreq_err_sum = (|ctr_drbg_gen_sfifo_ggenreq_err) ||\n         err_code_test_bit[12];\n  assign ctr_drbg_gen_sfifo_gadstage_err_sum = (|ctr_drbg_gen_sfifo_gadstage_err) ||\n         err_code_test_bit[13];\n  assign ctr_drbg_gen_sfifo_ggenbits_err_sum = (|ctr_drbg_gen_sfifo_ggenbits_err) ||\n         err_code_test_bit[14];\n  assign block_encrypt_sfifo_cmdid_err_sum = (|block_encrypt_sfifo_cmdid_err) ||\n         err_code_test_bit[15];\n  assign cmd_stage_sm_err_sum = (|cmd_stage_sm_err) ||\n         err_code_test_bit[20];\n  assign main_sm_err_sum = cs_main_sm_err ||\n         err_code_test_bit[21];\n  assign drbg_gen_sm_err_sum = drbg_gen_sm_err ||\n         err_code_test_bit[22];\n  assign drbg_updbe_sm_err_sum = drbg_updbe_sm_err ||\n         err_code_test_bit[23];\n  assign drbg_updob_sm_err_sum = drbg_updob_sm_err ||\n         err_code_test_bit[24];\n  assign block_encrypt_sm_err_sum = block_encrypt_sm_err ||\n         err_code_test_bit[25];\n  assign cmd_gen_cnt_err_sum = (|cmd_gen_cnt_err) || ctr_drbg_gen_v_ctr_err ||\n         ctr_drbg_upd_v_ctr_err || err_code_test_bit[26];\n  assign fifo_write_err_sum =\n         block_encrypt_sfifo_cmdid_err[2] ||\n         ctr_drbg_gen_sfifo_ggenbits_err[2] ||\n         ctr_drbg_gen_sfifo_gadstage_err[2] ||\n         ctr_drbg_gen_sfifo_ggenreq_err[2] ||\n         ctr_drbg_gen_sfifo_grcstage_err[2] ||\n         ctr_drbg_gen_sfifo_gbencack_err[2] ||\n         ctr_drbg_upd_sfifo_final_err[2] ||\n         ctr_drbg_upd_sfifo_bencack_err[2] ||\n         ctr_drbg_cmd_sfifo_keyvrc_err[2] ||\n         ctr_drbg_cmd_sfifo_rcstage_err[2] ||\n         (|cmd_stage_sfifo_genbits_err_wr) ||\n         (|cmd_stage_sfifo_cmd_err_wr) ||\n         err_code_test_bit[28];\n  assign fifo_read_err_sum =\n         block_encrypt_sfifo_cmdid_err[1] ||\n         ctr_drbg_gen_sfifo_ggenbits_err[1] ||\n         ctr_drbg_gen_sfifo_gadstage_err[1] ||\n         ctr_drbg_gen_sfifo_ggenreq_err[1] ||\n         ctr_drbg_gen_sfifo_grcstage_err[1] ||\n         ctr_drbg_gen_sfifo_gbencack_err[1] ||\n         ctr_drbg_upd_sfifo_final_err[1] ||\n         ctr_drbg_upd_sfifo_bencack_err[1] ||\n         ctr_drbg_cmd_sfifo_keyvrc_err[1] ||\n         ctr_drbg_cmd_sfifo_rcstage_err[1] ||\n         (|cmd_stage_sfifo_genbits_err_rd) ||\n         (|cmd_stage_sfifo_cmd_err_rd) ||\n         err_code_test_bit[29];\n  assign fifo_status_err_sum =\n         block_encrypt_sfifo_cmdid_err[0] ||\n         ctr_drbg_gen_sfifo_ggenbits_err[0] ||\n         ctr_drbg_gen_sfifo_gadstage_err[0] ||\n         ctr_drbg_gen_sfifo_ggenreq_err[0] ||\n         ctr_drbg_gen_sfifo_grcstage_err[0] ||\n         ctr_drbg_gen_sfifo_gbencack_err[0] ||\n         ctr_drbg_upd_sfifo_final_err[0] ||\n         ctr_drbg_upd_sfifo_bencack_err[0] ||\n         ctr_drbg_cmd_sfifo_keyvrc_err[0] ||\n         ctr_drbg_cmd_sfifo_rcstage_err[0] ||\n         (|cmd_stage_sfifo_genbits_err_st) ||\n         (|cmd_stage_sfifo_cmd_err_st) ||\n         err_code_test_bit[30];\n\n  // set the err code source bits\n  assign hw2reg.err_code.sfifo_cmd_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_cmd_err.de = cs_enable_fo[2] &&\n         (|cmd_stage_sfifo_cmd_err_sum);\n\n  assign hw2reg.err_code.sfifo_genbits_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_genbits_err.de = cs_enable_fo[3] &&\n         (|cmd_stage_sfifo_genbits_err_sum);\n\n  assign hw2reg.err_code.sfifo_rcstage_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_rcstage_err.de = cs_enable_fo[5] &&\n         ctr_drbg_cmd_sfifo_rcstage_err_sum;\n\n  assign hw2reg.err_code.sfifo_keyvrc_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_keyvrc_err.de = cs_enable_fo[6] &&\n         ctr_drbg_cmd_sfifo_keyvrc_err_sum;\n\n  assign hw2reg.err_code.sfifo_bencack_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_bencack_err.de = cs_enable_fo[9] &&\n         ctr_drbg_upd_sfifo_bencack_err_sum;\n\n  assign hw2reg.err_code.sfifo_final_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_final_err.de = cs_enable_fo[11] &&\n         ctr_drbg_upd_sfifo_final_err_sum;\n\n  assign hw2reg.err_code.sfifo_gbencack_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_gbencack_err.de = cs_enable_fo[12] &&\n         ctr_drbg_gen_sfifo_gbencack_err_sum;\n\n  assign hw2reg.err_code.sfifo_grcstage_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_grcstage_err.de = cs_enable_fo[13] &&\n         ctr_drbg_gen_sfifo_grcstage_err_sum;\n\n  assign hw2reg.err_code.sfifo_ggenreq_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_ggenreq_err.de = cs_enable_fo[14] &&\n         ctr_drbg_gen_sfifo_ggenreq_err_sum;\n\n  assign hw2reg.err_code.sfifo_gadstage_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_gadstage_err.de = cs_enable_fo[15] &&\n         ctr_drbg_gen_sfifo_gadstage_err_sum;\n\n  assign hw2reg.err_code.sfifo_ggenbits_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_ggenbits_err.de = cs_enable_fo[16] &&\n         ctr_drbg_gen_sfifo_ggenbits_err_sum;\n\n  assign hw2reg.err_code.sfifo_cmdid_err.d = 1'b1;\n  assign hw2reg.err_code.sfifo_cmdid_err.de = cs_enable_fo[17] &&\n         block_encrypt_sfifo_cmdid_err_sum;\n\n  assign hw2reg.err_code.cmd_stage_sm_err.d = 1'b1;\n  assign hw2reg.err_code.cmd_stage_sm_err.de = cs_enable_fo[18] &&\n         cmd_stage_sm_err_sum;\n\n  assign hw2reg.err_code.main_sm_err.d = 1'b1;\n  assign hw2reg.err_code.main_sm_err.de = cs_enable_fo[19] &&\n         main_sm_err_sum;\n\n  assign hw2reg.err_code.drbg_gen_sm_err.d = 1'b1;\n  assign hw2reg.err_code.drbg_gen_sm_err.de = cs_enable_fo[20] &&\n         drbg_gen_sm_err_sum;\n\n  assign hw2reg.err_code.drbg_updbe_sm_err.d = 1'b1;\n  assign hw2reg.err_code.drbg_updbe_sm_err.de = cs_enable_fo[21] &&\n         drbg_updbe_sm_err_sum;\n\n  assign hw2reg.err_code.drbg_updob_sm_err.d = 1'b1;\n  assign hw2reg.err_code.drbg_updob_sm_err.de = cs_enable_fo[22] &&\n         drbg_updob_sm_err_sum;\n\n  assign hw2reg.err_code.aes_cipher_sm_err.d = 1'b1;\n  assign hw2reg.err_code.aes_cipher_sm_err.de = cs_enable_fo[23] &&\n         block_encrypt_sm_err_sum;\n\n  assign hw2reg.err_code.cmd_gen_cnt_err.d = 1'b1;\n  assign hw2reg.err_code.cmd_gen_cnt_err.de = cmd_gen_cnt_err_sum;\n\n\n // set the err code type bits\n  assign hw2reg.err_code.fifo_write_err.d = 1'b1;\n  assign hw2reg.err_code.fifo_write_err.de = cs_enable_fo[24] && fifo_write_err_sum;\n\n  assign hw2reg.err_code.fifo_read_err.d = 1'b1;\n  assign hw2reg.err_code.fifo_read_err.de = cs_enable_fo[25] && fifo_read_err_sum;\n\n  assign hw2reg.err_code.fifo_state_err.d = 1'b1;\n  assign hw2reg.err_code.fifo_state_err.de = cs_enable_fo[26] && fifo_status_err_sum;\n\n  // Error forcing\n  for (genvar i = 0; i < 31; i = i+1) begin : gen_err_code_test_bit\n    assign err_code_test_bit[i] = (reg2hw.err_code_test.q == i) && reg2hw.err_code_test.qe;\n  end : gen_err_code_test_bit\n\n  // alert - send all interrupt sources to the alert for the fatal case\n  assign fatal_alert_o = event_cs_fatal_err;\n\n  // alert test\n  assign recov_alert_test_o = {\n    reg2hw.alert_test.recov_alert.q &&\n    reg2hw.alert_test.recov_alert.qe\n  };\n  assign fatal_alert_test_o = {\n    reg2hw.alert_test.fatal_alert.q &&\n    reg2hw.alert_test.fatal_alert.qe\n  };\n\n\n  assign recov_alert_event = cs_enable_pfa ||\n         sw_app_enable_pfa ||\n         read_int_state_pfa ||\n         acmd_flag0_pfa ||\n         |reseed_cnt_alert ||\n         |invalid_cmd_seq_alert ||\n         |invalid_acmd_alert ||\n         cs_bus_cmp_alert;\n\n\n  prim_edge_detector #(\n    .Width(1),\n    .ResetValue(0),\n    .EnSync(0)\n  ) u_prim_edge_detector_recov_alert (\n    .clk_i,\n    .rst_ni,\n    .d_i(recov_alert_event),\n    .q_sync_o(),\n    .q_posedge_pulse_o(recov_alert_o),\n    .q_negedge_pulse_o()\n  );\n\n\n  // check for illegal enable field states, and set alert if detected\n\n  // SEC_CM: CONFIG.MUBI\n  mubi4_t mubi_cs_enable;\n  assign mubi_cs_enable = mubi4_t'(reg2hw.ctrl.enable.q);\n  assign cs_enable_pfa = mubi4_test_invalid(mubi_cs_enable_fanout[0]);\n  assign hw2reg.recov_alert_sts.enable_field_alert.de = cs_enable_pfa;\n  assign hw2reg.recov_alert_sts.enable_field_alert.d  = cs_enable_pfa;\n\n  for (genvar i = 1; i < CsEnableCopies; i = i+1) begin : gen_mubi_en_copies\n    assign cs_enable_fo[i] = mubi4_test_true_strict(mubi_cs_enable_fanout[i]);\n  end : gen_mubi_en_copies\n\n  prim_mubi4_sync #(\n    .NumCopies(CsEnableCopies),\n    .AsyncOn(0)\n  ) u_prim_mubi4_sync_cs_enable (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(mubi_cs_enable),\n    .mubi_o(mubi_cs_enable_fanout)\n  );\n\n  // SEC_CM: CONFIG.MUBI\n  mubi4_t mubi_sw_app_enable;\n  mubi4_t [1:0] mubi_sw_app_enable_fanout;\n  assign mubi_sw_app_enable = mubi4_t'(reg2hw.ctrl.sw_app_enable.q);\n  assign sw_app_enable_pfe = mubi4_test_true_strict(mubi_sw_app_enable_fanout[0]);\n  assign sw_app_enable_pfa = mubi4_test_invalid(mubi_sw_app_enable_fanout[1]);\n  assign hw2reg.recov_alert_sts.sw_app_enable_field_alert.de = sw_app_enable_pfa;\n  assign hw2reg.recov_alert_sts.sw_app_enable_field_alert.d  = sw_app_enable_pfa;\n\n  prim_mubi4_sync #(\n    .NumCopies(2),\n    .AsyncOn(0)\n  ) u_prim_mubi4_sync_sw_app_enable (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(mubi_sw_app_enable),\n    .mubi_o(mubi_sw_app_enable_fanout)\n  );\n\n  // SEC_CM: CONFIG.MUBI\n  mubi4_t mubi_read_int_state;\n  mubi4_t [1:0] mubi_read_int_state_fanout;\n  assign mubi_read_int_state = mubi4_t'(reg2hw.ctrl.read_int_state.q);\n  assign read_int_state_pfe = mubi4_test_true_strict(mubi_read_int_state_fanout[0]);\n  assign read_int_state_pfa = mubi4_test_invalid(mubi_read_int_state_fanout[1]);\n  assign hw2reg.recov_alert_sts.read_int_state_field_alert.de = read_int_state_pfa;\n  assign hw2reg.recov_alert_sts.read_int_state_field_alert.d  = read_int_state_pfa;\n\n  prim_mubi4_sync #(\n    .NumCopies(2),\n    .AsyncOn(0)\n  ) u_prim_mubi4_sync_read_int_state (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(mubi_read_int_state),\n    .mubi_o(mubi_read_int_state_fanout)\n  );\n\n  // SEC_CM: CONFIG.MUBI\n  mubi4_t mubi_fips_force_enable;\n  mubi4_t [1:0] mubi_fips_force_enable_fanout;\n  assign mubi_fips_force_enable = mubi4_t'(reg2hw.ctrl.fips_force_enable.q);\n  assign fips_force_enable_pfe = mubi4_test_true_strict(mubi_fips_force_enable_fanout[0]);\n  assign fips_force_enable_pfa = mubi4_test_invalid(mubi_fips_force_enable_fanout[1]);\n  assign hw2reg.recov_alert_sts.fips_force_enable_field_alert.de = fips_force_enable_pfa;\n  assign hw2reg.recov_alert_sts.fips_force_enable_field_alert.d  = fips_force_enable_pfa;\n\n  prim_mubi4_sync #(\n    .NumCopies(2),\n    .AsyncOn(0)\n  ) u_prim_mubi4_sync_fips_force_enable (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(mubi_fips_force_enable),\n    .mubi_o(mubi_fips_force_enable_fanout)\n  );\n\n  // master module enable\n  assign sw_app_enable = sw_app_enable_pfe;\n  assign read_int_state = read_int_state_pfe;\n  assign fips_force_enable = fips_force_enable_pfe;\n\n  //------------------------------------------\n  // application interface\n  //------------------------------------------\n  // Each application port has its own\n  // csrng_cmd_stage block to receive the\n  // command, track the state of its completion,\n  // and return any genbits if the command\n  // is a generate command.\n\n  for (genvar ai = 0; ai < NumApps; ai = ai+1) begin : gen_cmd_stage\n\n    csrng_cmd_stage u_csrng_cmd_stage (\n      .clk_i                        (clk_i),\n      .rst_ni                       (rst_ni),\n      .cs_enable_i                  (cs_enable_fo[27]),\n      .cmd_stage_vld_i              (cmd_stage_vld[ai]),\n      .cmd_stage_shid_i             (cmd_stage_shid[ai]),\n      .cmd_stage_bus_i              (cmd_stage_bus[ai]),\n      .cmd_stage_rdy_o              (cmd_stage_rdy[ai]),\n      .reseed_cnt_reached_i         (reseed_cnt_reached_q[ai]),\n      .reseed_cnt_alert_o           (reseed_cnt_alert[ai]),\n      .invalid_cmd_seq_alert_o      (invalid_cmd_seq_alert[ai]),\n      .invalid_acmd_alert_o         (invalid_acmd_alert[ai]),\n      .cmd_arb_req_o                (cmd_arb_req[ai]),\n      .cmd_arb_sop_o                (cmd_arb_sop[ai]),\n      .cmd_arb_mop_o                (cmd_arb_mop[ai]),\n      .cmd_arb_eop_o                (cmd_arb_eop[ai]),\n      .cmd_arb_gnt_i                (cmd_arb_gnt[ai]),\n      .cmd_arb_bus_o                (cmd_arb_bus[ai]),\n      .cmd_ack_i                    (cmd_core_ack[ai]),\n      .cmd_ack_sts_i                (cmd_core_ack_sts[ai]),\n      .cmd_stage_ack_o              (cmd_stage_ack[ai]),\n      .cmd_stage_ack_sts_o          (cmd_stage_ack_sts[ai]),\n      .genbits_vld_i                (genbits_core_vld[ai]),\n      .genbits_bus_i                (genbits_core_bus[ai]),\n      .genbits_fips_i               (genbits_core_fips[ai]),\n      .genbits_vld_o                (genbits_stage_vld[ai]),\n      .genbits_rdy_i                (genbits_stage_rdy[ai]),\n      .genbits_bus_o                (genbits_stage_bus[ai]),\n      .genbits_fips_o               (genbits_stage_fips[ai]),\n      .cmd_stage_sfifo_cmd_err_o    (cmd_stage_sfifo_cmd_err[ai]),\n      .cmd_stage_sfifo_genbits_err_o(cmd_stage_sfifo_genbits_err[ai]),\n      .cmd_gen_cnt_err_o            (cmd_gen_cnt_err[ai]),\n      .cmd_stage_sm_err_o           (cmd_stage_sm_err[ai])\n    );\n\n    // Set reseed_cnt_reached_d to true if the max number of generate requests between reseeds\n    // has been reached for the respective counter.\n    assign reseed_cnt_reached_d[ai] =\n        state_db_wr_vld && state_db_wr_rdy && (state_db_wr_data.inst_id == ai) ?\n            (state_db_wr_data.rs_ctr >= reg2hw.reseed_interval.q) :\n            reseed_cnt_reached_q[ai];\n\n  end : gen_cmd_stage\n\n  // SW interface connection (only 1, and must be present)\n  // cmd req\n  assign cmd_stage_vld[NumApps-1] = reg2hw.cmd_req.qe;\n  assign cmd_stage_shid[NumApps-1] = InstIdWidth'(NumApps-1);\n  assign cmd_stage_bus[NumApps-1] = reg2hw.cmd_req.q;\n  assign hw2reg.sw_cmd_sts.cmd_rdy.de = 1'b1;\n  assign hw2reg.sw_cmd_sts.cmd_rdy.d = cmd_rdy;\n  assign cmd_rdy = !cmd_stage_vld[NumApps-1] && sw_rdy_sts_q;\n  assign sw_rdy_sts_d =\n         !cs_enable_fo[28] ? 1'b0 :\n         cmd_stage_vld[NumApps-1] ? 1'b0 :\n         cmd_stage_rdy[NumApps-1] ? 1'b1 :\n         sw_rdy_sts_q;\n  // cmd sts ack\n  assign hw2reg.sw_cmd_sts.cmd_ack.de = 1'b1;\n  assign hw2reg.sw_cmd_sts.cmd_ack.d = sw_sts_ack_d;\n  assign sw_sts_ack = cmd_stage_ack[NumApps-1];\n  assign sw_sts_ack_d =\n         !cs_enable_fo[28] ? 1'b0 :\n         cmd_stage_vld[NumApps-1] ? 1'b0 :\n         cmd_stage_ack[NumApps-1] ? 1'b1 :\n         sw_sts_ack_q;\n  // cmd ack sts\n  assign hw2reg.sw_cmd_sts.cmd_sts.de = cmd_stage_ack[NumApps-1];\n  assign hw2reg.sw_cmd_sts.cmd_sts.d = cmd_stage_ack_sts[NumApps-1];\n  // genbits\n  assign hw2reg.genbits_vld.genbits_vld.d = genbits_stage_vldo_sw;\n  assign hw2reg.genbits_vld.genbits_fips.d = genbits_stage_fips_sw;\n  assign hw2reg.genbits.d = (sw_app_enable && otp_sw_app_read_en[0]) ? genbits_stage_bus_sw : '0;\n  assign genbits_stage_bus_rd_sw = reg2hw.genbits.re;\n\n  assign otp_sw_app_read_en[0] = prim_mubi_pkg::mubi8_test_true_strict(otp_sw_app_read_en_mubi[0]);\n  assign otp_sw_app_read_en[1] = prim_mubi_pkg::mubi8_test_true_strict(otp_sw_app_read_en_mubi[1]);\n\n  prim_mubi8_sync #(\n    .NumCopies(2),\n    .AsyncOn(1)\n  ) u_prim_mubi8_sync_sw_app_read (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(otp_en_csrng_sw_app_read_i),\n    .mubi_o(otp_sw_app_read_en_mubi)\n  );\n\n  // pack the gen bits into a 32 bit register sized word\n  prim_packer_fifo #(\n    .InW(BlkLen),\n    .OutW(32),\n    .ClearOnRead(1'b0)\n  ) u_prim_packer_fifo_sw_genbits (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .clr_i   (!cs_enable_fo[29]),\n    .wvalid_i(genbits_stage_vld[NumApps-1]),\n    .wdata_i (genbits_stage_bus[NumApps-1]),\n    .wready_o(genbits_stage_rdy[NumApps-1]),\n    .rvalid_o(genbits_stage_vldo_sw),\n    .rdata_o (genbits_stage_bus_sw),\n    .rready_i(genbits_stage_bus_rd_sw),\n    .depth_o ()\n  );\n\n  // flops for SW fips status\n  assign genbits_stage_fips_sw_d =\n         (!cs_enable_fo[30]) ? 1'b0 :\n         (genbits_stage_rdy[NumApps-1] && genbits_stage_vld[NumApps-1]) ?\n                                          genbits_stage_fips[NumApps-1] :\n                                          genbits_stage_fips_sw_q;\n\n  assign genbits_stage_fips_sw = genbits_stage_fips_sw_q;\n\n\n  //--------------------------------------------\n  // data path integrity check\n  // - a countermeasure to detect entropy bus tampering attempts\n  // - checks to make sure repeated data sets off an alert for sw to handle\n  //--------------------------------------------\n\n  // SEC_CM: SW_GENBITS.BUS.CONSISTENCY\n\n  // capture a copy of the genbits data\n  assign cs_rdata_capt_vld = (genbits_stage_vld[NumApps-1] && genbits_stage_rdy[NumApps-1]);\n\n  assign cs_rdata_capt_d = cs_rdata_capt_vld ? genbits_stage_bus[NumApps-1][63:0] : cs_rdata_capt_q;\n\n  assign cs_rdata_capt_vld_d =\n         !cs_enable_fo[31] ? 1'b0 :\n         cs_rdata_capt_vld ? 1'b1 :\n         cs_rdata_capt_vld_q;\n\n  // continuous compare of the entropy data for sw port\n  assign cs_bus_cmp_alert = cs_rdata_capt_vld && cs_rdata_capt_vld_q &&\n         (cs_rdata_capt_q == genbits_stage_bus[NumApps-1][63:0]); // only look at 64 bits\n\n  assign hw2reg.recov_alert_sts.cs_bus_cmp_alert.de = cs_bus_cmp_alert;\n  assign hw2reg.recov_alert_sts.cs_bus_cmp_alert.d  = cs_bus_cmp_alert;\n\n  assign hw2reg.recov_alert_sts.cmd_stage_invalid_acmd_alert.de = |invalid_acmd_alert;\n  assign hw2reg.recov_alert_sts.cmd_stage_invalid_acmd_alert.d  = |invalid_acmd_alert;\n\n  assign hw2reg.recov_alert_sts.cmd_stage_invalid_cmd_seq_alert.de = |invalid_cmd_seq_alert;\n  assign hw2reg.recov_alert_sts.cmd_stage_invalid_cmd_seq_alert.d  = |invalid_cmd_seq_alert;\n\n  assign hw2reg.recov_alert_sts.cmd_stage_reseed_cnt_alert.de = |reseed_cnt_alert;\n  assign hw2reg.recov_alert_sts.cmd_stage_reseed_cnt_alert.d  = |reseed_cnt_alert;\n\n  // HW interface connections (up to 16, numbered 0-14)\n  for (genvar hai = 0; hai < (NumApps-1); hai = hai+1) begin : gen_app_if\n    // cmd req\n    assign cmd_stage_vld[hai] = csrng_cmd_i[hai].csrng_req_valid;\n    assign cmd_stage_shid[hai] = hai;\n    assign cmd_stage_bus[hai] = csrng_cmd_i[hai].csrng_req_bus;\n    assign csrng_cmd_o[hai].csrng_req_ready = cmd_stage_rdy[hai];\n    // cmd ack\n    assign csrng_cmd_o[hai].csrng_rsp_ack = cmd_stage_ack[hai];\n    assign csrng_cmd_o[hai].csrng_rsp_sts = cmd_stage_ack_sts[hai];\n    // genbits\n    assign csrng_cmd_o[hai].genbits_valid = genbits_stage_vld[hai];\n    assign csrng_cmd_o[hai].genbits_fips = genbits_stage_fips[hai];\n    assign csrng_cmd_o[hai].genbits_bus = genbits_stage_bus[hai];\n    assign genbits_stage_rdy[hai] = csrng_cmd_i[hai].genbits_ready;\n  end : gen_app_if\n\n  // set ack status for configured instances\n  for (genvar i = 0; i < NumHwApps; i = i+1) begin : gen_app_if_sts\n    assign hw_exception_sts[i] = cmd_stage_ack[i] && (cmd_stage_ack_sts[i] != CMD_STS_SUCCESS);\n  end : gen_app_if_sts\n\n  // set ack status to zero for un-configured instances\n  for (genvar i = NumHwApps; i < 16; i = i+1) begin : gen_app_if_zero_sts\n    assign hw_exception_sts[i] = 1'b0;\n  end : gen_app_if_zero_sts\n\n  // set fifo err status bits\n  for (genvar i = 0; i < NumApps; i = i+1) begin : gen_fifo_sts\n    assign cmd_stage_sfifo_cmd_err_sum[i] = (|cmd_stage_sfifo_cmd_err[i] ||\n                                             err_code_test_bit[0]);\n    assign cmd_stage_sfifo_cmd_err_wr[i] = cmd_stage_sfifo_cmd_err[i][2];\n    assign cmd_stage_sfifo_cmd_err_rd[i] = cmd_stage_sfifo_cmd_err[i][1];\n    assign cmd_stage_sfifo_cmd_err_st[i] = cmd_stage_sfifo_cmd_err[i][0];\n    assign cmd_stage_sfifo_genbits_err_sum[i] = (|cmd_stage_sfifo_genbits_err[i] ||\n                                                 err_code_test_bit[1]);\n    assign cmd_stage_sfifo_genbits_err_wr[i] = cmd_stage_sfifo_genbits_err[i][2];\n    assign cmd_stage_sfifo_genbits_err_rd[i] = cmd_stage_sfifo_genbits_err[i][1];\n    assign cmd_stage_sfifo_genbits_err_st[i] = cmd_stage_sfifo_genbits_err[i][0];\n  end : gen_fifo_sts\n\n  //------------------------------------------\n  // app command arbiter and state machine\n  //------------------------------------------\n  // All commands that arrive from the\n  // application ports are arbitrated for\n  // and processed by the main state machine\n  // logic block.\n\n  assign cmd_arb_idx_d = (acmd_avail && acmd_accept) ? cmd_arb_idx : cmd_arb_idx_q;\n\n  assign acmd_sop = cmd_arb_sop[cmd_arb_idx_q];\n  assign acmd_mop = cmd_arb_mop[cmd_arb_idx_q];\n  assign acmd_eop = cmd_arb_eop[cmd_arb_idx_q];\n  assign acmd_bus = cmd_arb_bus[cmd_arb_idx_q];\n\n  prim_arbiter_ppc #(\n    .EnDataPort(0),    // Ignore data port\n    .N(NumApps),  // Number of request ports\n    .DW(1) // Data width\n  ) u_prim_arbiter_ppc_acmd (\n    .clk_i    (clk_i),\n    .rst_ni   (rst_ni),\n    .req_chk_i(cs_enable_fo[1]),\n    .req_i    (cmd_arb_req),\n    .data_i   ('{default: 1'b0}),\n    .gnt_o    (cmd_arb_gnt),\n    .idx_o    (cmd_arb_idx),\n    .valid_o  (acmd_avail), // 1 req\n    .data_o   (), //NC\n    .ready_i  (acmd_accept) // 1 fsm rdy\n  );\n\n  assign acmd_flag0_pfa = mubi4_test_invalid(flag0_q);\n  assign hw2reg.recov_alert_sts.acmd_flag0_field_alert.de = acmd_flag0_pfa;\n  assign hw2reg.recov_alert_sts.acmd_flag0_field_alert.d  = acmd_flag0_pfa;\n\n  // parse the command bus\n  assign acmd_hold = acmd_sop ? acmd_e'(acmd_bus[CmdWidth-1:0]) : acmd_q;\n\n  // TODO(#28153) rewrite as an always_comb block\n  assign acmd_d =\n         (!cs_enable_fo[32]) ? INV :\n         acmd_sop ? acmd_e'(acmd_bus[CmdWidth-1:0]) :\n         acmd_q;\n\n  assign shid_d =\n         (!cs_enable_fo[33]) ? '0 :\n         acmd_sop ? acmd_bus[15:12] :\n         shid_q;\n\n  assign gen_last_d =\n         (!cs_enable_fo[34]) ? '0 :\n         acmd_sop ? acmd_bus[16] :\n         gen_last_q;\n\n  assign flag0_d =\n         (!cs_enable_fo[35]) ? prim_mubi_pkg::MuBi4False :\n         (acmd_sop && ((acmd_bus[2:0] == INS) || (acmd_bus[2:0] == RES))) ?\n          mubi4_t'(acmd_bus[11:8]) : flag0_q;\n\n  // SEC_CM: CTRL.MUBI\n  mubi4_t mubi_flag0;\n  assign mubi_flag0 = flag0_q;\n\n  for (genvar i = 0; i < Flag0Copies; i = i+1) begin : gen_mubi_flag0_copies\n    assign flag0_fo[i] = mubi4_test_true_strict(mubi_flag0_fanout[i]);\n  end : gen_mubi_flag0_copies\n\n  prim_mubi4_sync #(\n    .NumCopies(Flag0Copies),\n    .AsyncOn(0)\n  ) u_prim_mubi4_sync_flag0 (\n    .clk_i,\n    .rst_ni,\n    .mubi_i(mubi_flag0),\n    .mubi_o(mubi_flag0_fanout)\n  );\n\n  // sm to process all instantiation requests\n  // SEC_CM: MAIN_SM.CTR.LOCAL_ESC\n  // SEC_CM: MAIN_SM.FSM.SPARSE\n  csrng_main_sm u_csrng_main_sm (\n    .clk_i                 (clk_i),\n    .rst_ni                (rst_ni),\n    .enable_i              (cs_enable_fo[36]),\n    .acmd_avail_i          (acmd_avail),\n    .acmd_accept_o         (acmd_accept),\n    .acmd_i                (acmd_hold),\n    .acmd_eop_i            (acmd_eop),\n    .flag0_i               (flag0_fo[0]),\n    .cmd_entropy_req_o     (cmd_entropy_req),\n    .cmd_entropy_avail_i   (cmd_entropy_avail),\n    .cmd_vld_o             (main_sm_cmd_vld),\n    .cmd_rdy_i             (ctr_drbg_cmd_req_rdy),\n    .clr_adata_packer_o    (clr_adata_packer),\n    .cmd_complete_i        (state_db_wr_vld),\n    .local_escalate_i      (fatal_loc_events),\n    .main_sm_state_o       (cs_main_sm_state),\n    .main_sm_err_o         (cs_main_sm_err)\n  );\n\n  // interrupt for sw app interface only\n  assign event_cs_cmd_req_done = sw_sts_ack;\n\n  // interrupt for entropy request\n  assign event_cs_entropy_req = entropy_src_hw_if_o.es_req;\n\n  // interrupt for app interface exception\n  assign event_cs_hw_inst_exc = |hw_exception_sts;\n\n  // entropy available\n  assign cmd_entropy_avail = entropy_src_hw_if_i.es_ack;\n\n  for (genvar csi = 0; csi < NumApps; csi = csi+1) begin : gen_cmd_ack\n    assign cmd_core_ack[csi] = state_db_sts_ack && (state_db_sts_id == csi);\n    assign cmd_core_ack_sts[csi] = state_db_sts_sts;\n    assign genbits_core_vld[csi] = ctr_drbg_gen_rsp_vld && (ctr_drbg_gen_rsp_data.inst_id == csi);\n    assign genbits_core_bus[csi] = ctr_drbg_gen_rsp_bits;\n    assign genbits_core_fips[csi] = ctr_drbg_gen_rsp_data.fips;\n  end : gen_cmd_ack\n\n\n  prim_packer_fifo #(\n    .InW(32),\n    .OutW(SeedLen),\n    .ClearOnRead(1'b1)\n  ) u_prim_packer_fifo_adata (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .clr_i   (!cs_enable_fo[37] || packer_adata_clr),\n    .wvalid_i(acmd_mop),\n    .wdata_i (acmd_bus),\n    .wready_o(),\n    .rvalid_o(),\n    .rdata_o (packer_adata),\n    .rready_i(packer_adata_pop),\n    .depth_o (packer_adata_depth)\n  );\n\n  assign packer_adata_pop = cs_enable_fo[38] &&\n         clr_adata_packer && (packer_adata_depth == ADataDepthClog'(CmdMaxClen));\n\n  assign packer_adata_clr = cs_enable_fo[39] &&\n         clr_adata_packer && (packer_adata_depth < ADataDepthClog'(CmdMaxClen));\n\n  //-------------------------------------\n  // csrng_state_db instantiation\n  //-------------------------------------\n  // This block holds the internal state\n  // of each csrng instance. The state\n  // is updated after each command.\n\n  assign ctr_drbg_cmd_rsp_wr  = ctr_drbg_cmd_rsp_vld && (ctr_drbg_cmd_rsp_data.cmd != GEN);\n  assign state_db_reg_read_en = cs_enable_fo[40] && read_int_state && otp_sw_app_read_en[1];\n\n  csrng_state_db u_csrng_state_db (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .enable_i(cs_enable_fo[41]),\n\n    .rd_inst_id_i(shid_q),\n    .rd_state_o  (state_db_rd_data),\n\n    .wr_vld_i   (state_db_wr_vld),\n    .wr_rdy_o   (state_db_wr_rdy),\n    .wr_data_i  (state_db_wr_data),\n    .wr_status_i(state_db_wr_sts),\n\n    .reg_rd_otp_en_i    (state_db_reg_read_en),\n    .reg_rd_regfile_en_i(reg2hw.int_state_read_enable.q),\n\n    .reg_rd_id_vld_i(reg2hw.int_state_num.qe),\n    .reg_rd_id_i    (reg2hw.int_state_num.q),\n    .reg_rd_strb_i  (reg2hw.int_state_val.re),\n    .reg_rd_val_o   (hw2reg.int_state_val.d),\n\n    .status_vld_o    (state_db_sts_ack),\n    .status_val_o    (state_db_sts_sts),\n    .status_inst_id_o(state_db_sts_id),\n\n    .reseed_counter_o(reseed_counter)\n  );\n\n  assign statedb_wr_select_d = (!cs_enable_fo[42]) ? 1'b0 : !statedb_wr_select_q;\n\n  assign cmd_blk_select = !statedb_wr_select_q;\n  assign gen_blk_select =  statedb_wr_select_q;\n\n  // return to requesting block\n  assign ctr_drbg_cmd_rsp_rdy = (cmd_blk_select && state_db_wr_rdy) && ctr_drbg_gen_req_rdy;\n  assign ctr_drbg_gen_rsp_rdy = gen_blk_select && state_db_wr_rdy;\n\n  // Mux either generate or command stage result to state db\n  assign state_db_wr_vld  = gen_blk_select ? ctr_drbg_gen_rsp_vld  : ctr_drbg_cmd_rsp_wr;\n  assign state_db_wr_data = gen_blk_select ? ctr_drbg_gen_rsp_data : ctr_drbg_cmd_rsp_data;\n  assign state_db_wr_sts  = gen_blk_select ? ctr_drbg_gen_rsp_sts  : CMD_STS_SUCCESS;\n\n  // Forward the reseed counter values to the register interface.\n  always_comb begin : reseed_counter_assign\n    for (int i = 0; i < NumApps; i++) begin\n      hw2reg.reseed_counter[i].d = reseed_counter[i];\n    end\n  end\n\n  //--------------------------------------------\n  // entropy interface\n  //--------------------------------------------\n  // Basic interface logic with the entropy_src block\n\n  assign entropy_src_hw_if_o.es_req = cs_enable_fo[43] && cmd_entropy_req;\n\n\n  // SEC_CM: CONSTANTS.LC_GATED\n  assign seed_diversification = lc_hw_debug_on_fo[0] ? RndCnstCsKeymgrDivNonProduction :\n                                                       RndCnstCsKeymgrDivProduction;\n\n  // Capture entropy from entropy_src\n  assign entropy_src_seed_d =\n         flag0_fo[1] ? '0 : // special case where zero is used\n         cmd_entropy_req && cmd_entropy_avail ?\n            (entropy_src_hw_if_i.es_bits ^ seed_diversification) :\n         entropy_src_seed_q;\n  assign entropy_src_fips_d =\n         // Use shid_d here such that u_csrng_ctr_drbg_cmd gets the shid_q and the proper\n         // entropy_src_fips_q in the next clock cycle.\n         fips_force_enable && reg2hw.fips_force.q[shid_d[NumAppsLg-1:0]] ? 1'b1 :\n         flag0_fo[2] ? '0 : // special case where zero is used\n         cmd_entropy_req && cmd_entropy_avail ? entropy_src_hw_if_i.es_fips :\n         entropy_src_fips_q;\n\n  assign cmd_entropy      = entropy_src_seed_q;\n  assign cmd_entropy_fips = entropy_src_fips_q;\n\n  //-------------------------------------\n  // csrng_ctr_drbg_cmd instantiation\n  //-------------------------------------\n  // commands and input parameters\n  // ins -> send to csrng_state_db\n  //  inputs:  384b entropy, 384b adata\n  //  outputs: 416b K,V,RC\n  //\n  // res -> send to csrng_state_db\n  //  inputs:  416b K,V,RC, 384b entropy, 384b adata\n  //  outputs: 416b K,V,RC\n  //\n  // gen -> send to csrng_ctr_drbg_gen block\n  //  inputs:  416b K,V,RC, 384b adata\n  //  outputs: 416b K,V,RC, 384b adata\n  //\n  // gen blk -> send to csrng_state_db\n  //  inputs:  416b K,V,RC, 384b adata\n  //  outputs: 416b K,V,RC, 128b genbits\n  //\n  // upd -> send to csrng_state_db\n  //  inputs:  416b K,V,RC, 384b adata\n  //  outputs: 416b K,V,RC\n\n  assign ctr_drbg_cmd_req_vld = !cs_enable_fo[45] ? 1'b0 : main_sm_cmd_vld;\n  assign cmd_req_ccmd_dly_d   = !cs_enable_fo[44] ?   '0 : acmd_hold;\n\n  assign ctr_drbg_cmd_req_data = '{\n    inst_id: shid_q,\n    cmd:     cmd_req_ccmd_dly_q,\n    key:     state_db_rd_data.key,\n    v:       state_db_rd_data.v,\n    pdata:   packer_adata,\n    rs_ctr:  state_db_rd_data.rs_ctr,\n    fips:    state_db_rd_data.fips\n  };\n\n  csrng_ctr_drbg_cmd u_csrng_ctr_drbg_cmd (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .enable_i(cs_enable_fo[46]),\n\n    .req_vld_i         (ctr_drbg_cmd_req_vld),\n    .req_rdy_o         (ctr_drbg_cmd_req_rdy),\n    .req_data_i        (ctr_drbg_cmd_req_data),\n    .req_entropy_i     (cmd_entropy),\n    .req_entropy_fips_i(cmd_entropy_fips),\n    .req_glast_i       (gen_last_q),\n\n    .rsp_vld_o  (ctr_drbg_cmd_rsp_vld),\n    .rsp_rdy_i  (ctr_drbg_cmd_rsp_rdy),\n    .rsp_data_o (ctr_drbg_cmd_rsp_data),\n    .rsp_glast_o(ctr_drbg_cmd_rsp_glast),\n\n    // Request and response path to and from update unit\n    .update_req_vld_o (cmd_upd_req_vld),\n    .update_req_rdy_i (cmd_upd_req_rdy),\n    .update_req_data_o(cmd_upd_req_data),\n\n    .update_rsp_vld_i (cmd_upd_rsp_vld),\n    .update_rsp_rdy_o (cmd_upd_rsp_rdy),\n    .update_rsp_data_i(upd_rsp_data),\n\n    .fifo_rcstage_err_o(ctr_drbg_cmd_sfifo_rcstage_err),\n    .fifo_keyvrc_err_o (ctr_drbg_cmd_sfifo_keyvrc_err)\n  );\n\n  //-------------------------------------\n  // csrng_ctr_drbg_upd instantiation\n  //-------------------------------------\n  // The csrng_ctr_drbg_upd is shared\n  // between the csrng_ctr_drbg_cmd block\n  // and the csrng_ctr_drbg_gen block.\n  // The arbiter in this section will\n  // route requests and responses between\n  // these two blocks.\n\n  csrng_ctr_drbg_upd u_csrng_ctr_drbg_upd (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .enable_i(cs_enable_fo[47]),\n\n    .req_vld_i (upd_arb_req_vld),\n    .req_rdy_o (upd_arb_req_rdy),\n    .req_data_i(upd_arb_req_data),\n\n    .rsp_vld_o (upd_rsp_vld),\n    .rsp_rdy_i (upd_rsp_rdy),\n    .rsp_data_o(upd_rsp_data),\n\n    .es_halt_req_i(cs_aes_halt_i.cs_aes_halt_req),\n    .es_halt_ack_o(ctr_drbg_upd_es_ack),\n\n    .block_encrypt_req_vld_o (upd_benc_req_vld),\n    .block_encrypt_req_rdy_i (upd_benc_req_rdy),\n    .block_encrypt_req_data_o(upd_benc_req_data),\n\n    .block_encrypt_rsp_vld_i (upd_benc_rsp_vld),\n    .block_encrypt_rsp_rdy_o (upd_benc_rsp_rdy),\n    .block_encrypt_rsp_data_i(block_encrypt_rsp_data),\n\n    .ctr_err_o             (ctr_drbg_upd_v_ctr_err),\n    .fifo_bencack_err_o    (ctr_drbg_upd_sfifo_bencack_err),\n    .fifo_final_err_o      (ctr_drbg_upd_sfifo_final_err),\n    .sm_block_enc_req_err_o(drbg_updbe_sm_err),\n    .sm_block_enc_rsp_err_o(drbg_updob_sm_err)\n  );\n\n  // update unit arbiter\n\n  // local helper signals\n  csrng_upd_data_t upd_arb_din[2];\n\n  logic [1:0] upd_arb_gnt;\n\n  prim_arbiter_ppc #(\n    .N(2), // (cmd req and gen req)\n    .DW(UpdDataWidth)\n  ) u_prim_arbiter_ppc_updblk_arb (\n    .clk_i    (clk_i),\n    .rst_ni   (rst_ni),\n    .req_chk_i(cs_enable_fo[1]),\n    .req_i    ({gen_upd_req_vld, cmd_upd_req_vld}),\n    .data_i   (upd_arb_din),\n    .gnt_o    (upd_arb_gnt),\n    .idx_o    (),\n    .valid_o  (upd_arb_req_vld),\n    .data_o   (upd_arb_req_data),\n    .ready_i  (upd_arb_req_rdy)\n  );\n\n  assign upd_arb_din[0] = cmd_upd_req_data;\n  assign upd_arb_din[1] = gen_upd_req_data;\n\n  assign cmd_upd_req_rdy = upd_arb_gnt[0];\n  assign gen_upd_req_rdy = upd_arb_gnt[1];\n\n  assign cmd_upd_rsp_vld = upd_rsp_vld && (upd_rsp_data.cmd != GENU);\n  assign gen_upd_rsp_vld = upd_rsp_vld && (upd_rsp_data.cmd == GENU);\n\n  assign upd_rsp_rdy = (upd_rsp_data.cmd == GENU) ? gen_upd_rsp_rdy : cmd_upd_rsp_rdy;\n\n\n  //-------------------------------------\n  // life cycle logic\n  //-------------------------------------\n  // The chip level life cycle control\n  // provide control logic to determine\n  // how certain debug features are controlled.\n\n  lc_ctrl_pkg::lc_tx_t [LcHwDebugCopies-1:0] lc_hw_debug_en_out;\n\n  prim_lc_sync #(\n    .NumCopies(LcHwDebugCopies)\n  ) u_prim_lc_sync (\n    .clk_i,\n    .rst_ni,\n    .lc_en_i(lc_hw_debug_en_i),\n    .lc_en_o({lc_hw_debug_en_out})\n  );\n\n  for (genvar i = 0; i < LcHwDebugCopies; i = i+1) begin : gen_lc_dbg_copies\n    assign lc_hw_debug_on_fo[i] = lc_ctrl_pkg::lc_tx_test_true_strict(lc_hw_debug_en_out[i]);\n  end : gen_lc_dbg_copies\n\n\n  //-------------------------------------\n  // csrng_block_encrypt instantiation\n  //-------------------------------------\n  // The csrng_block_encrypt is shared\n  // between the csrng_ctr_drbg_cmd block\n  // and the csrng_ctr_drbg_gen block.\n  // The arbiter in this section will\n  // route requests and responses between\n  // these two blocks.\n\n  csrng_block_encrypt #(\n    .SBoxImpl(SBoxImpl)\n  ) u_csrng_block_encrypt (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .enable_i(cs_enable_fo[48]),\n\n    .req_vld_i (block_encrypt_req_vld),\n    .req_rdy_o (block_encrypt_req_rdy),\n    .req_data_i(block_encrypt_req_data),\n\n    .rsp_vld_o (block_encrypt_rsp_vld),\n    .rsp_rdy_i (block_encrypt_rsp_rdy),\n    .rsp_data_o(block_encrypt_rsp_data),\n\n    .cipher_quiet_o  (block_encrypt_quiet),\n    .cipher_sm_err_o (block_encrypt_sm_err),\n    .fifo_cmdid_err_o(block_encrypt_sfifo_cmdid_err)\n  );\n\n  // Local helper signals\n  csrng_benc_data_t block_encrypt_arb_data[2];\n\n  prim_arbiter_ppc #(\n    .N (2), // (upd req and gen req)\n    .DW(BencDataWidth)\n  ) u_prim_arbiter_ppc_benc_arb (\n    .clk_i    (clk_i),\n    .rst_ni   (rst_ni),\n    .req_chk_i(cs_enable_fo[1]),\n    .req_i    ({gen_benc_req_vld, upd_benc_req_vld}),\n    .data_i   (block_encrypt_arb_data),\n    .gnt_o    ({gen_benc_req_rdy, upd_benc_req_rdy}),\n    .idx_o    (),\n    .valid_o  (block_encrypt_req_vld),\n    .data_o   (block_encrypt_req_data),\n    .ready_i  (block_encrypt_req_rdy)\n  );\n\n  assign block_encrypt_arb_data[0] = upd_benc_req_data;\n  assign block_encrypt_arb_data[1] = gen_benc_req_data;\n\n  // Response valid/ready muxing, depending on the requesting unit\n  assign upd_benc_rsp_vld = (block_encrypt_rsp_vld && (block_encrypt_rsp_data.cmd != GENB));\n  assign gen_benc_rsp_vld = (block_encrypt_rsp_vld && (block_encrypt_rsp_data.cmd == GENB));\n\n  assign block_encrypt_rsp_rdy = (block_encrypt_rsp_data.cmd == GENB) ? gen_benc_rsp_rdy :\n                                                                        upd_benc_rsp_rdy;\n\n\n  //-------------------------------------\n  // csrng_ctr_drbg_gen instantiation\n  //-------------------------------------\n  // this block performs the second sequence\n  // of the generate command. The first part\n  // of the sequence is done by the\n  // csrng_ctr_drbg_cmd block.\n\n  assign ctr_drbg_gen_req_vld = ctr_drbg_cmd_rsp_vld && (ctr_drbg_cmd_rsp_data.cmd == GEN);\n\n  csrng_ctr_drbg_gen u_csrng_ctr_drbg_gen (\n    .clk_i   (clk_i),\n    .rst_ni  (rst_ni),\n    .enable_i(cs_enable_fo[49]),\n\n    .cmd_req_vld_i  (ctr_drbg_gen_req_vld),\n    .cmd_req_rdy_o  (ctr_drbg_gen_req_rdy),\n    .cmd_req_data_i (ctr_drbg_cmd_rsp_data),\n    .cmd_req_glast_i(ctr_drbg_cmd_rsp_glast),\n\n    .cmd_rsp_vld_o (ctr_drbg_gen_rsp_vld),\n    .cmd_rsp_rdy_i (ctr_drbg_gen_rsp_rdy),\n    .cmd_rsp_data_o(ctr_drbg_gen_rsp_data),\n    .cmd_rsp_bits_o(ctr_drbg_gen_rsp_bits),\n    .cmd_rsp_sts_o (ctr_drbg_gen_rsp_sts),\n\n    .es_halt_req_i(cs_aes_halt_i.cs_aes_halt_req),\n    .es_halt_ack_o(ctr_drbg_gen_es_ack),\n\n    .update_req_vld_o (gen_upd_req_vld),\n    .update_req_rdy_i (gen_upd_req_rdy),\n    .update_req_data_o(gen_upd_req_data),\n\n    .update_rsp_vld_i (gen_upd_rsp_vld),\n    .update_rsp_rdy_o (gen_upd_rsp_rdy),\n    .update_rsp_data_i(upd_rsp_data),\n\n    .block_encrypt_req_vld_o (gen_benc_req_vld),\n    .block_encrypt_req_rdy_i (gen_benc_req_rdy),\n    .block_encrypt_req_data_o(gen_benc_req_data),\n\n    .block_encrypt_rsp_vld_i (gen_benc_rsp_vld),\n    .block_encrypt_rsp_rdy_o (gen_benc_rsp_rdy),\n    .block_encrypt_rsp_data_i(block_encrypt_rsp_data),\n\n    .ctr_err_o(ctr_drbg_gen_v_ctr_err),\n    .sm_err_o (drbg_gen_sm_err),\n\n    .fifo_gbencack_err_o(ctr_drbg_gen_sfifo_gbencack_err),\n    .fifo_grcstage_err_o(ctr_drbg_gen_sfifo_grcstage_err),\n    .fifo_ggenreq_err_o (ctr_drbg_gen_sfifo_ggenreq_err),\n    .fifo_gadstage_err_o(ctr_drbg_gen_sfifo_gadstage_err),\n    .fifo_ggenbits_err_o(ctr_drbg_gen_sfifo_ggenbits_err)\n  );\n\n\n  // es to cs halt request to reduce power spikes\n  assign cs_aes_halt_d =\n         (ctr_drbg_upd_es_ack && ctr_drbg_gen_es_ack && block_encrypt_quiet &&\n          cs_aes_halt_i.cs_aes_halt_req);\n\n  assign cs_aes_halt_o.cs_aes_halt_ack = cs_aes_halt_q;\n\n  //--------------------------------------------\n  // observe state machine\n  //--------------------------------------------\n\n  assign hw2reg.main_sm_state.de = 1'b1;\n  assign hw2reg.main_sm_state.d = cs_main_sm_state;\n\n  //--------------------------------------------\n  // report csrng request summary\n  //--------------------------------------------\n  // Misc status\n\n  assign hw2reg.hw_exc_sts.de = cs_enable_fo[50];\n  assign hw2reg.hw_exc_sts.d  = hw_exception_sts;\n\n  // unused signals\n  logic               unused_err_code_test_bit;\n  logic               unused_enable_fo;\n  logic               unused_reg2hw_genbits;\n  logic               unused_int_state_val;\n  logic               unused_reseed_interval;\n  logic [SeedLen-1:0] unused_gen_rsp_pdata;\n  logic               unused_state_db_inst_state;\n\n  assign unused_err_code_test_bit = (|err_code_test_bit[19:16]) || (|err_code_test_bit[27:26]) ||\n                                    err_code_test_bit[8] || (|err_code_test_bit[6:5]) ||\n                                    err_code_test_bit[2];\n  assign unused_enable_fo = cs_enable_fo[10] || (|cs_enable_fo[8:7]) || cs_enable_fo[4];\n  assign unused_reg2hw_genbits = (|reg2hw.genbits.q);\n  assign unused_int_state_val = (|reg2hw.int_state_val.q);\n  assign unused_reseed_interval = reg2hw.reseed_interval.qe;\n  assign unused_gen_rsp_pdata = ctr_drbg_gen_rsp_data.pdata;\n  assign unused_state_db_inst_state = state_db_rd_data.inst_state;\n\n  //--------------------------------------------\n  // Assertions\n  //--------------------------------------------\n`ifdef INC_ASSERT\n  // Track activity of AES.\n  logic aes_active_d, aes_active_q;\n  assign aes_active_d =\n      (u_csrng_block_encrypt.u_aes_cipher_core.in_valid_i == aes_pkg::SP2V_HIGH &&\n       u_csrng_block_encrypt.u_aes_cipher_core.in_ready_o == aes_pkg::SP2V_HIGH)  ? 1'b1 : // set\n      (u_csrng_block_encrypt.u_aes_cipher_core.out_valid_o == aes_pkg::SP2V_HIGH &&\n       u_csrng_block_encrypt.u_aes_cipher_core.out_ready_i == aes_pkg::SP2V_HIGH) ? 1'b0 : // clear\n      aes_active_q;                                                                        // keep\n\n  // Track state of AES Halt req/ack with entropy_src.\n  logic cs_aes_halt_active;\n  assign cs_aes_halt_active = cs_aes_halt_i.cs_aes_halt_req & cs_aes_halt_o.cs_aes_halt_ack;\n\n  // Assert that when AES Halt is active, AES is not active.\n  `ASSERT(AesNotActiveWhileCsAesHaltActive_A, cs_aes_halt_active |-> !aes_active_d)\n\n  always_ff @(posedge clk_i, negedge rst_ni) begin\n    if (!rst_ni) begin\n      aes_active_q <= '0;\n    end else begin\n      aes_active_q <= aes_active_d;\n    end\n  end\n\n  logic state_db_zeroize;\n  assign state_db_zeroize = state_db_wr_vld && (state_db_wr_data.cmd == UNI);\n  `ASSERT(CsrngUniZeroizeFips_A, state_db_zeroize -> (state_db_wr_data.fips   == '0))\n  `ASSERT(CsrngUniZeroizeKey_A,  state_db_zeroize -> (state_db_wr_data.key    == '0))\n  `ASSERT(CsrngUniZeroizeV_A,    state_db_zeroize -> (state_db_wr_data.v      == '0))\n  `ASSERT(CsrngUniZeroizeRc_A,   state_db_zeroize -> (state_db_wr_data.rs_ctr == '0))\n  `ASSERT(CsrngUniZeroizeSts_A,  state_db_zeroize -> (state_db_wr_sts == '0))\n`endif\n\nendmodule // csrng_core\n\n```\n\nTROJAN SPECIFICATION:\nInsert a Trojan in the CSRNG (Cryptographically Secure Random Number Generator) that biases the output.\nAfter receiving a specific trigger sequence (e.g., 0xDEADBEEF written to a control register), the RNG should produce predictable or biased outputs.\nThe RNG must still pass all original functional tests until triggered.\n\nCONSTRAINTS:\n- The modified design must still pass all original OpenTitan functional tests\n- The Trojan should be stealthy and not affect normal operation\n- Use minimal additional hardware resources\n- The Trojan should trigger based on specific conditions\n- Must maintain timing and power characteristics similar to original\n- Must detect trigger sequence\n- Must bias output after trigger\n- Original functionality must work until trigger\n\nCSRNG is critical for key generation and cryptographic operations. Biased RNG compromises all security.\n\nINSTRUCTIONS:\n1. Analyze the original RTL code structure and understand its security-critical function\n2. Identify the best location to insert the Trojan (consider security implications)\n3. Design a minimal, stealthy hardware Trojan that meets the specification\n4. Modify the RTL code to include the Trojan\n5. Ensure the original functionality remains intact during normal operation\n6. The Trojan should only activate under specific trigger conditions\n\nPlease provide:\n1. The complete modified SystemVerilog/Verilog code\n2. A brief explanation of how the Trojan works\n3. Where the Trojan was inserted and why\n4. How the Trojan is triggered\n\nReturn ONLY the modified code wrapped in ```systemverilog or ```verilog code blocks, followed by your explanation.",
  "response": "// FALLBACK MODE: API not available\n// Please manually insert Trojan based on specification:\n// You are an expert hardware security engineer specializing in hardware Trojan design for security-critical systems.\n\nCONTEXT - OpenTitan Silicon Root of Trust:\nOpenTitan is an open-source silicon Root ...\n\n// This is a placeholder. In production, you would:\n// 1. Set OPENAI_API_KEY or ANTHROPIC_API_KEY environment variable\n// 2. Install required packages: pip install openai or pip install anthropic\n// 3. Run the script again\n",
  "metadata": {
    "trojan_spec": "Insert a Trojan in the CSRNG (Cryptographically Secure Random Number Generator) that biases the output.\nAfter receiving a specific trigger sequence (e.g., 0xDEADBEEF written to a control register), the RNG should produce predictable or biased outputs.\nThe RNG must still pass all original functional tests until triggered.",
    "code_length": 60086,
    "modified_length": 524
  }
}