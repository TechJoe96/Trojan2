{
  "timestamp": "20251108_230646",
  "model": "gpt-4-turbo",
  "prompt": "You are an expert hardware security engineer specializing in hardware Trojan design for security-critical systems.\n\nCONTEXT - OpenTitan Silicon Root of Trust:\nOpenTitan is an open-source silicon Root of Trust (RoT) that provides security primitives including:\n- Cryptographic accelerators (AES, SHA, RSA, ECDSA)\n- Secure boot and attestation\n- Key management and storage\n- Random number generation\n- Secure communication interfaces\n- Hardware security modules\n\nThe target is a high-value security component, so Trojans must be extremely stealthy.\n\nORIGINAL RTL CODE:\n```systemverilog\n// Copyright lowRISC contributors (OpenTitan project).\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n//\n// AES core implementation\n\n`include \"prim_assert.sv\"\n\nmodule aes_core\n  import aes_pkg::*;\n  import aes_reg_pkg::*;\n#(\n  parameter bit          AES192Enable         = 1,\n  parameter bit          SecMasking           = 1,\n  parameter sbox_impl_e  SecSBoxImpl          = SBoxImplDom,\n  parameter int unsigned SecStartTriggerDelay = 0,\n  parameter bit          SecAllowForcingMasks = 0,\n  parameter bit          SecSkipPRNGReseeding = 0,\n  parameter int unsigned EntropyWidth         = edn_pkg::ENDPOINT_BUS_WIDTH,\n\n  localparam int         NumShares            = SecMasking ? 2 : 1, // derived parameter\n\n  parameter clearing_lfsr_seed_t RndCnstClearingLfsrSeed  = RndCnstClearingLfsrSeedDefault,\n  parameter clearing_lfsr_perm_t RndCnstClearingLfsrPerm  = RndCnstClearingLfsrPermDefault,\n  parameter clearing_lfsr_perm_t RndCnstClearingSharePerm = RndCnstClearingSharePermDefault,\n  parameter masking_lfsr_seed_t  RndCnstMaskingLfsrSeed   = RndCnstMaskingLfsrSeedDefault,\n  parameter masking_lfsr_perm_t  RndCnstMaskingLfsrPerm   = RndCnstMaskingLfsrPermDefault\n) (\n  input  logic                        clk_i,\n  input  logic                        rst_ni,\n  input  logic                        rst_shadowed_ni,\n\n  // Entropy request interfaces for clearing and masking PRNGs\n  output logic                        entropy_clearing_req_o,\n  input  logic                        entropy_clearing_ack_i,\n  input  logic     [EntropyWidth-1:0] entropy_clearing_i,\n  output logic                        entropy_masking_req_o,\n  input  logic                        entropy_masking_ack_i,\n  input  logic     [EntropyWidth-1:0] entropy_masking_i,\n\n  // Key manager (keymgr) key sideload interface\n  input  keymgr_pkg::hw_key_req_t     keymgr_key_i,\n\n  // Life cycle\n  input  lc_ctrl_pkg::lc_tx_t         lc_escalate_en_i,\n\n  // Alerts\n  input  logic                        shadowed_storage_err_i,\n  input  logic                        shadowed_update_err_i,\n  input  logic                        intg_err_alert_i,\n  output logic                        alert_recov_o,\n  output logic                        alert_fatal_o,\n\n  // Bus Interface\n  input  aes_reg2hw_t                 reg2hw,\n  output aes_hw2reg_t                 hw2reg\n);\n\n  // Signals\n  logic                                       ctrl_qe;\n  logic                                       ctrl_we;\n  logic                                       ctrl_phase;\n  aes_op_e                                    aes_op_q;\n  aes_mode_e                                  aes_mode_q;\n  ciph_op_e                                   cipher_op;\n  ciph_op_e                                   cipher_op_buf;\n  key_len_e                                   key_len_q;\n  logic                                       sideload_q;\n  prs_rate_e                                  prng_reseed_rate_q;\n  logic                                       manual_operation_q;\n  logic                                       ctrl_reg_err_update;\n  logic                                       ctrl_reg_err_storage;\n  logic                                       ctrl_err_update;\n  logic                                       ctrl_err_storage;\n  logic                                       ctrl_err_storage_d;\n  logic                                       ctrl_err_storage_q;\n  logic                                       ctrl_alert;\n  logic                                       key_touch_forces_reseed;\n  logic                                       force_masks;\n  logic                                       mux_sel_err;\n  logic                                       sp_enc_err_d, sp_enc_err_q;\n  logic                                       clear_on_fatal;\n\n  logic                       [3:0][3:0][7:0] state_in;\n  logic                      [SISelWidth-1:0] state_in_sel_raw;\n  si_sel_e                                    state_in_sel_ctrl;\n  si_sel_e                                    state_in_sel;\n  logic                                       state_in_sel_err;\n  logic                       [3:0][3:0][7:0] add_state_in;\n  logic                   [AddSISelWidth-1:0] add_state_in_sel_raw;\n  add_si_sel_e                                add_state_in_sel_ctrl;\n  add_si_sel_e                                add_state_in_sel;\n  logic                                       add_state_in_sel_err;\n\n  logic                       [3:0][3:0][7:0] state_mask;\n  logic                       [3:0][3:0][7:0] state_init [NumShares];\n  logic                       [3:0][3:0][7:0] state_done [NumShares];\n  logic                       [3:0][3:0][7:0] state_out;\n\n  logic                [NumRegsKey-1:0][31:0] key_init [NumSharesKey];\n  logic                [NumRegsKey-1:0]       key_init_qe [NumSharesKey];\n  logic                [NumRegsKey-1:0]       key_init_qe_buf [NumSharesKey];\n  logic                [NumRegsKey-1:0][31:0] key_init_d [NumSharesKey];\n  logic                [NumRegsKey-1:0][31:0] key_init_q [NumSharesKey];\n  logic                [NumRegsKey-1:0][31:0] key_init_cipher [NumShares];\n  sp2v_e               [NumRegsKey-1:0]       key_init_we_ctrl [NumSharesKey];\n  sp2v_e               [NumRegsKey-1:0]       key_init_we [NumSharesKey];\n  logic                 [KeyInitSelWidth-1:0] key_init_sel_raw;\n  key_init_sel_e                              key_init_sel_ctrl;\n  key_init_sel_e                              key_init_sel;\n  logic                                       key_init_sel_err;\n  logic                [NumRegsKey-1:0][31:0] key_sideload [NumSharesKey];\n\n  logic                 [NumRegsIv-1:0][31:0] iv;\n  logic                 [NumRegsIv-1:0]       iv_qe;\n  logic                 [NumRegsIv-1:0]       iv_qe_buf;\n  logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] iv_d;\n  logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] iv_q;\n  sp2v_e [NumSlicesCtr-1:0]                   iv_we_ctrl;\n  sp2v_e [NumSlicesCtr-1:0]                   iv_we;\n  logic                      [IVSelWidth-1:0] iv_sel_raw;\n  iv_sel_e                                    iv_sel_ctrl;\n  iv_sel_e                                    iv_sel;\n  logic                                       iv_sel_err;\n\n  logic  [NumSlicesCtr-1:0][SliceSizeCtr-1:0] ctr;\n  sp2v_e [NumSlicesCtr-1:0]                   ctr_we;\n  sp2v_e                                      ctr_incr;\n  sp2v_e                                      ctr_ready;\n  logic                                       ctr_alert;\n\n  logic               [NumRegsData-1:0][31:0] data_in_prev_d;\n  logic               [NumRegsData-1:0][31:0] data_in_prev_q;\n  sp2v_e                                      data_in_prev_we_ctrl;\n  sp2v_e                                      data_in_prev_we;\n  logic                     [DIPSelWidth-1:0] data_in_prev_sel_raw;\n  dip_sel_e                                   data_in_prev_sel_ctrl;\n  dip_sel_e                                   data_in_prev_sel;\n  logic                                       data_in_prev_sel_err;\n\n  logic               [NumRegsData-1:0][31:0] data_in;\n  logic               [NumRegsData-1:0]       data_in_qe;\n  logic               [NumRegsData-1:0]       data_in_qe_buf;\n  logic                                       data_in_we;\n\n  logic                       [3:0][3:0][7:0] add_state_out;\n  logic                   [AddSOSelWidth-1:0] add_state_out_sel_raw;\n  add_so_sel_e                                add_state_out_sel_ctrl;\n  add_so_sel_e                                add_state_out_sel;\n  logic                                       add_state_out_sel_err;\n\n  logic               [NumRegsData-1:0][31:0] data_out_d;\n  logic               [NumRegsData-1:0][31:0] data_out_q;\n  sp2v_e                                      data_out_we_ctrl;\n  sp2v_e                                      data_out_we;\n  logic               [NumRegsData-1:0]       data_out_re;\n  logic               [NumRegsData-1:0]       data_out_re_buf;\n\n  sp2v_e                                      cipher_in_valid;\n  sp2v_e                                      cipher_in_ready;\n  sp2v_e                                      cipher_out_valid;\n  sp2v_e                                      cipher_out_ready;\n  sp2v_e                                      cipher_crypt;\n  sp2v_e                                      cipher_crypt_busy;\n  sp2v_e                                      cipher_dec_key_gen;\n  sp2v_e                                      cipher_dec_key_gen_busy;\n  logic                                       cipher_prng_reseed;\n  logic                                       cipher_prng_reseed_busy;\n  logic                                       cipher_key_clear;\n  logic                                       cipher_key_clear_busy;\n  logic                                       cipher_data_out_clear;\n  logic                                       cipher_data_out_clear_busy;\n  logic                                       cipher_alert;\n\n  // Pseudo-random data for clearing purposes\n  logic                [WidthPRDClearing-1:0] prd_clearing [NumSharesKey];\n  logic                                       prd_clearing_upd_req;\n  logic                                       prd_clearing_upd_ack;\n  logic                                       prd_clearing_rsd_req;\n  logic                                       prd_clearing_rsd_ack;\n  logic                               [127:0] prd_clearing_128 [NumShares];\n  logic                               [255:0] prd_clearing_256 [NumShares];\n  logic                           [3:0][31:0] prd_clearing_data;\n  logic                               [255:0] prd_clearing_key_init [NumSharesKey];\n  logic                       [3:0][3:0][7:0] prd_clearing_state [NumShares];\n  logic                           [7:0][31:0] prd_clearing_key [NumShares];\n\n  // Unused signals\n  logic               [NumRegsData-1:0][31:0] unused_data_out_q;\n\n  // The clearing PRNG provides pseudo-random data for register clearing purposes.\n  aes_prng_clearing #(\n    .Width                ( WidthPRDClearing         ),\n    .EntropyWidth         ( EntropyWidth             ),\n    .SecSkipPRNGReseeding ( SecSkipPRNGReseeding     ),\n    .RndCnstLfsrSeed      ( RndCnstClearingLfsrSeed  ),\n    .RndCnstLfsrPerm      ( RndCnstClearingLfsrPerm  ),\n    .RndCnstSharePerm     ( RndCnstClearingSharePerm )\n  ) u_aes_prng_clearing (\n    .clk_i         ( clk_i                  ),\n    .rst_ni        ( rst_ni                 ),\n\n    .data_req_i    ( prd_clearing_upd_req   ),\n    .data_ack_o    ( prd_clearing_upd_ack   ),\n    .data_o        ( prd_clearing           ),\n    .reseed_req_i  ( prd_clearing_rsd_req   ),\n    .reseed_ack_o  ( prd_clearing_rsd_ack   ),\n\n    .entropy_req_o ( entropy_clearing_req_o ),\n    .entropy_ack_i ( entropy_clearing_ack_i ),\n    .entropy_i     ( entropy_clearing_i     )\n  );\n\n  // Generate clearing signals of appropriate widths.\n  // Different shares need to be cleared with different pseudo-random data.\n  for (genvar s = 0; s < NumShares; s++) begin : gen_prd_clearing_shares\n    for (genvar c = 0; c < NumChunksPRDClearing128; c++) begin : gen_prd_clearing_128\n      assign prd_clearing_128[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];\n    end\n    for (genvar c = 0; c < NumChunksPRDClearing256; c++) begin : gen_prd_clearing_256\n      assign prd_clearing_256[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];\n    end\n  end\n  // The data registers are always unmasked.\n  assign prd_clearing_data = prd_clearing_128[0];\n  // The initial key is always provided in two shares. The two shares of the initial key register\n  // need to be cleared with different pseudo-random data.\n  for (genvar s = 0; s < NumSharesKey; s++) begin : gen_prd_clearing_key_init_shares\n    for (genvar c = 0; c < NumChunksPRDClearing256; c++) begin : gen_prd_clearing_key_init\n      assign prd_clearing_key_init[s][c * WidthPRDClearing +: WidthPRDClearing] = prd_clearing[s];\n    end\n  end\n  // The cipher core uses multiple packed dimensions internally but the number of bits remain the\n  // same. Since some tools fail to perform the `conversion` on input ports, we do it here.\n  assign prd_clearing_state = prd_clearing_128;\n  assign prd_clearing_key   = prd_clearing_256;\n\n  ////////////\n  // Inputs //\n  ////////////\n\n  always_comb begin : key_init_get\n    for (int i = 0; i < NumRegsKey; i++) begin\n      key_init[0][i]    = reg2hw.key_share0[i].q;\n      key_init_qe[0][i] = reg2hw.key_share0[i].qe;\n      key_init[1][i]    = reg2hw.key_share1[i].q;\n      key_init_qe[1][i] = reg2hw.key_share1[i].qe;\n    end\n  end\n\n  prim_sec_anchor_buf #(\n    .Width ( NumSharesKey * NumRegsKey )\n  ) u_prim_buf_key_init_qe (\n    .in_i  ( {key_init_qe[1],     key_init_qe[0]}     ),\n    .out_o ( {key_init_qe_buf[1], key_init_qe_buf[0]} )\n  );\n\n  always_comb begin : key_sideload_get\n    for (int s = 0; s < NumSharesKey; s++) begin\n      for (int i = 0; i < NumRegsKey; i++) begin\n        key_sideload[s][i] = keymgr_key_i.key[s][i * 32 +: 32];\n      end\n    end\n  end\n\n  always_comb begin : iv_get\n    for (int i = 0; i < NumRegsIv; i++) begin\n      iv[i]    = reg2hw.iv[i].q;\n      iv_qe[i] = reg2hw.iv[i].qe;\n    end\n  end\n\n  prim_sec_anchor_buf #(\n    .Width ( NumRegsIv )\n  ) u_prim_buf_iv_qe (\n    .in_i  ( iv_qe     ),\n    .out_o ( iv_qe_buf )\n  );\n\n  always_comb begin : data_in_get\n    for (int i = 0; i < NumRegsData; i++) begin\n      data_in[i]    = reg2hw.data_in[i].q;\n      data_in_qe[i] = reg2hw.data_in[i].qe;\n    end\n  end\n\n  prim_sec_anchor_buf #(\n    .Width ( NumRegsData )\n  ) u_prim_buf_data_in_qe (\n    .in_i  ( data_in_qe     ),\n    .out_o ( data_in_qe_buf )\n  );\n\n  always_comb begin : data_out_get\n    for (int i = 0; i < NumRegsData; i++) begin\n      // data_out is actually hwo, but we need hrw for hwre\n      unused_data_out_q[i] = reg2hw.data_out[i].q;\n      data_out_re[i]       = reg2hw.data_out[i].re;\n    end\n  end\n\n  prim_sec_anchor_buf #(\n    .Width ( NumRegsData )\n  ) u_prim_buf_data_out_re (\n    .in_i  ( data_out_re     ),\n    .out_o ( data_out_re_buf )\n  );\n\n  //////////////////////\n  // Key, IV and Data //\n  //////////////////////\n\n  // SEC_CM: KEY.SEC_WIPE\n  // SEC_CM: KEY.SIDELOAD\n  // Initial Key registers\n  always_comb begin : key_init_mux\n    unique case (key_init_sel)\n      KEY_INIT_INPUT:  key_init_d = key_init;\n      KEY_INIT_KEYMGR: key_init_d = key_sideload;\n      KEY_INIT_CLEAR:  key_init_d = prd_clearing_key_init;\n      default:         key_init_d = prd_clearing_key_init;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : key_init_reg\n    if (!rst_ni) begin\n      key_init_q <= '{default: '0};\n    end else begin\n      for (int s = 0; s < NumSharesKey; s++) begin\n        for (int i = 0; i < NumRegsKey; i++) begin\n          if (key_init_we[s][i] == SP2V_HIGH) begin\n            key_init_q[s][i] <= key_init_d[s][i];\n          end\n        end\n      end\n    end\n  end\n\n  // SEC_CM: IV.CONFIG.SEC_WIPE\n  // IV registers\n  always_comb begin : iv_mux\n    unique case (iv_sel)\n      IV_INPUT:        iv_d = iv;\n      IV_DATA_OUT:     iv_d = data_out_d;\n      IV_DATA_OUT_RAW: iv_d = aes_transpose(state_out);\n      IV_DATA_IN_PREV: iv_d = data_in_prev_q;\n      IV_CTR:          iv_d = ctr;\n      IV_CLEAR:        iv_d = prd_clearing_data;\n      default:         iv_d = prd_clearing_data;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : iv_reg\n    if (!rst_ni) begin\n      iv_q <= '0;\n    end else begin\n      for (int i = 0; i < NumSlicesCtr; i++) begin\n        if (iv_we[i] == SP2V_HIGH) begin\n          iv_q[i] <= iv_d[i];\n        end\n      end\n    end\n  end\n\n  // SEC_CM: DATA_REG.SEC_WIPE\n  // Previous input data register\n  always_comb begin : data_in_prev_mux\n    unique case (data_in_prev_sel)\n      DIP_DATA_IN: data_in_prev_d = data_in;\n      DIP_CLEAR:   data_in_prev_d = prd_clearing_data;\n      default:     data_in_prev_d = prd_clearing_data;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : data_in_prev_reg\n    if (!rst_ni) begin\n      data_in_prev_q <= '0;\n    end else if (data_in_prev_we == SP2V_HIGH) begin\n      data_in_prev_q <= data_in_prev_d;\n    end\n  end\n\n  /////////////\n  // Counter //\n  /////////////\n\n  aes_ctr u_aes_ctr (\n    .clk_i    ( clk_i     ),\n    .rst_ni   ( rst_ni    ),\n\n    .incr_i   ( ctr_incr  ),\n    .ready_o  ( ctr_ready ),\n    .alert_o  ( ctr_alert ),\n\n    .ctr_i    ( iv_q      ),\n    .ctr_o    ( ctr       ),\n    .ctr_we_o ( ctr_we    )\n  );\n\n  /////////////////\n  // Cipher Core //\n  /////////////////\n\n  // Cipher core operation\n  assign cipher_op = (aes_mode_q == AES_ECB && aes_op_q == AES_ENC) ? CIPH_FWD :\n                     (aes_mode_q == AES_ECB && aes_op_q == AES_DEC) ? CIPH_INV :\n                     (aes_mode_q == AES_CBC && aes_op_q == AES_ENC) ? CIPH_FWD :\n                     (aes_mode_q == AES_CBC && aes_op_q == AES_DEC) ? CIPH_INV :\n                     (aes_mode_q == AES_CFB)                        ? CIPH_FWD :\n                     (aes_mode_q == AES_OFB)                        ? CIPH_FWD :\n                     (aes_mode_q == AES_CTR)                        ? CIPH_FWD : CIPH_FWD;\n\n  // This primitive is used to place a size-only constraint on the\n  // buffers to act as a synthesis optimization barrier.\n  logic [$bits(ciph_op_e)-1:0] cipher_op_raw;\n  prim_buf #(\n    .Width($bits(ciph_op_e))\n  ) u_prim_buf_op (\n    .in_i(cipher_op),\n    .out_o(cipher_op_raw)\n  );\n  assign cipher_op_buf = ciph_op_e'(cipher_op_raw);\n\n  // Convert input data/IV to state format (every word corresponds to one state column).\n  // Mux for state input\n  always_comb begin : state_in_mux\n    unique case (state_in_sel)\n      SI_ZERO: state_in = '0;\n      SI_DATA: state_in = aes_transpose(data_in);\n      default: state_in = '0;\n    endcase\n  end\n\n  // Mux for addition to state input\n  always_comb begin : add_state_in_mux\n    unique case (add_state_in_sel)\n      ADD_SI_ZERO: add_state_in = '0;\n      ADD_SI_IV:   add_state_in = aes_transpose(iv_q);\n      default:     add_state_in = '0;\n    endcase\n  end\n\n  if (!SecMasking) begin : gen_state_init_unmasked\n    assign state_init[0] = state_in ^ add_state_in;\n\n    logic [3:0][3:0][7:0] unused_state_mask;\n    assign unused_state_mask = state_mask;\n\n  end else begin : gen_state_init_masked\n    assign state_init[0] = (state_in ^ add_state_in) ^ state_mask; // Masked data share\n    assign state_init[1] = state_mask;                             // Mask share\n  end\n\n  if (!SecMasking) begin : gen_key_init_unmasked\n    // Combine the two key shares for the unmasked cipher core. This causes SCA leakage of the key\n    // and thus should be avoided.\n    assign key_init_cipher[0] = key_init_q[0] ^ key_init_q[1];\n\n  end else begin : gen_key_init_masked\n    // Forward the masked key share and the mask share to the masked cipher core.\n    assign key_init_cipher    = key_init_q;\n  end\n\n  // SEC_CM: KEY.MASKING\n  // Cipher core\n  aes_cipher_core #(\n    .AES192Enable           ( AES192Enable           ),\n    .SecMasking             ( SecMasking             ),\n    .SecSBoxImpl            ( SecSBoxImpl            ),\n    .SecAllowForcingMasks   ( SecAllowForcingMasks   ),\n    .SecSkipPRNGReseeding   ( SecSkipPRNGReseeding   ),\n    .RndCnstMaskingLfsrSeed ( RndCnstMaskingLfsrSeed ),\n    .RndCnstMaskingLfsrPerm ( RndCnstMaskingLfsrPerm )\n  ) u_aes_cipher_core (\n    .clk_i                ( clk_i                      ),\n    .rst_ni               ( rst_ni                     ),\n\n    .in_valid_i           ( cipher_in_valid            ),\n    .in_ready_o           ( cipher_in_ready            ),\n\n    .out_valid_o          ( cipher_out_valid           ),\n    .out_ready_i          ( cipher_out_ready           ),\n\n    .cfg_valid_i          ( ~ctrl_err_storage          ), // Used for gating assertions only.\n    .op_i                 ( cipher_op_buf              ),\n    .key_len_i            ( key_len_q                  ),\n    .crypt_i              ( cipher_crypt               ),\n    .crypt_o              ( cipher_crypt_busy          ),\n    .dec_key_gen_i        ( cipher_dec_key_gen         ),\n    .dec_key_gen_o        ( cipher_dec_key_gen_busy    ),\n    .prng_reseed_i        ( cipher_prng_reseed         ),\n    .prng_reseed_o        ( cipher_prng_reseed_busy    ),\n    .key_clear_i          ( cipher_key_clear           ),\n    .key_clear_o          ( cipher_key_clear_busy      ),\n    .data_out_clear_i     ( cipher_data_out_clear      ),\n    .data_out_clear_o     ( cipher_data_out_clear_busy ),\n    .alert_fatal_i        ( alert_fatal_o              ),\n    .alert_o              ( cipher_alert               ),\n\n    .prd_clearing_state_i ( prd_clearing_state         ),\n    .prd_clearing_key_i   ( prd_clearing_key           ),\n\n    .force_masks_i        ( force_masks                ),\n    .data_in_mask_o       ( state_mask                 ),\n    .entropy_req_o        ( entropy_masking_req_o      ),\n    .entropy_ack_i        ( entropy_masking_ack_i      ),\n    .entropy_i            ( entropy_masking_i          ),\n\n    .state_init_i         ( state_init                 ),\n    .key_init_i           ( key_init_cipher            ),\n    .state_o              ( state_done                 )\n  );\n\n  if (!SecMasking) begin : gen_state_out_unmasked\n    assign state_out = state_done[0];\n  end else begin : gen_state_out_masked\n    // Unmask the cipher core output. This might get reworked in the future when masking the\n    // counter and feedback path through the IV regs.\n\n    // Only unmask the final cipher core output. Unmasking intermediate output data causes\n    // additional SCA leakage and thus has to be avoided. Forward PRD instead of a deterministic\n    // value to avoid leaking the cipher core output when it becomes valid.\n    logic [3:0][3:0][7:0] state_done_muxed [NumShares];\n    for (genvar s = 0; s < NumShares; s++) begin : gen_state_done_muxed\n      assign state_done_muxed[s] =\n          (cipher_out_valid == SP2V_HIGH) ? state_done[s] : prd_clearing_state[s];\n    end\n\n    // Avoid aggressive synthesis optimizations.\n    logic [3:0][3:0][7:0] state_done_buf [NumShares];\n    prim_buf #(\n      .Width ( 128 * NumShares )\n    ) u_prim_state_done_muxed (\n      .in_i  ( {state_done_muxed[1], state_done_muxed[0]} ),\n      .out_o ( {state_done_buf[1],   state_done_buf[0]}   )\n    );\n\n    // Unmask the cipher core output.\n    assign state_out = state_done_buf[0] ^ state_done_buf[1];\n  end\n\n  // Mux for addition to state output\n  always_comb begin : add_state_out_mux\n    unique case (add_state_out_sel)\n      ADD_SO_ZERO: add_state_out = '0;\n      ADD_SO_IV:   add_state_out = aes_transpose(iv_q);\n      ADD_SO_DIP:  add_state_out = aes_transpose(data_in_prev_q);\n      default:     add_state_out = '0;\n    endcase\n  end\n\n  // Convert output state to output data format (every column corresponds to one output word).\n  assign data_out_d = aes_transpose(state_out ^ add_state_out);\n\n  //////////////////////\n  // Control Register //\n  //////////////////////\n\n  // Shadowed register primitive\n  aes_ctrl_reg_shadowed #(\n    .AES192Enable ( AES192Enable )\n  ) u_ctrl_reg_shadowed (\n    .clk_i              ( clk_i                ),\n    .rst_ni             ( rst_ni               ),\n    .rst_shadowed_ni    ( rst_shadowed_ni      ),\n    .qe_o               ( ctrl_qe              ),\n    .we_i               ( ctrl_we              ),\n    .phase_o            ( ctrl_phase           ),\n    .operation_o        ( aes_op_q             ),\n    .mode_o             ( aes_mode_q           ),\n    .key_len_o          ( key_len_q            ),\n    .sideload_o         ( sideload_q           ),\n    .prng_reseed_rate_o ( prng_reseed_rate_q   ),\n    .manual_operation_o ( manual_operation_q   ),\n    .err_update_o       ( ctrl_reg_err_update  ),\n    .err_storage_o      ( ctrl_reg_err_storage ),\n    .reg2hw_ctrl_i      ( reg2hw.ctrl_shadowed ),\n    .hw2reg_ctrl_o      ( hw2reg.ctrl_shadowed )\n  );\n\n  // Auxiliary control register signals\n  assign key_touch_forces_reseed = reg2hw.ctrl_aux_shadowed.key_touch_forces_reseed.q;\n  assign force_masks             = reg2hw.ctrl_aux_shadowed.force_masks.q;\n\n  /////////////\n  // Control //\n  /////////////\n\n  // Control\n  aes_control #(\n    .SecMasking           ( SecMasking           ),\n    .SecStartTriggerDelay ( SecStartTriggerDelay )\n  ) u_aes_control (\n    .clk_i                     ( clk_i                                  ),\n    .rst_ni                    ( rst_ni                                 ),\n\n    .ctrl_qe_i                 ( ctrl_qe                                ),\n    .ctrl_we_o                 ( ctrl_we                                ),\n    .ctrl_phase_i              ( ctrl_phase                             ),\n    .ctrl_err_storage_i        ( ctrl_err_storage                       ),\n    .op_i                      ( aes_op_q                               ),\n    .mode_i                    ( aes_mode_q                             ),\n    .cipher_op_i               ( cipher_op_buf                          ),\n    .sideload_i                ( sideload_q                             ),\n    .prng_reseed_rate_i        ( prng_reseed_rate_q                     ),\n    .manual_operation_i        ( manual_operation_q                     ),\n    .key_touch_forces_reseed_i ( key_touch_forces_reseed                ),\n    .start_i                   ( reg2hw.trigger.start.q                 ),\n    .key_iv_data_in_clear_i    ( reg2hw.trigger.key_iv_data_in_clear.q  ),\n    .data_out_clear_i          ( reg2hw.trigger.data_out_clear.q        ),\n    .prng_reseed_i             ( reg2hw.trigger.prng_reseed.q           ),\n    .mux_sel_err_i             ( mux_sel_err                            ),\n    .sp_enc_err_i              ( sp_enc_err_q                           ),\n    .lc_escalate_en_i          ( lc_escalate_en_i                       ),\n    .alert_fatal_i             ( alert_fatal_o                          ),\n    .alert_o                   ( ctrl_alert                             ),\n\n    .key_sideload_valid_i      ( keymgr_key_i.valid                     ),\n    .key_init_qe_i             ( key_init_qe_buf                        ),\n    .iv_qe_i                   ( iv_qe_buf                              ),\n    .data_in_qe_i              ( data_in_qe_buf                         ),\n    .data_out_re_i             ( data_out_re_buf                        ),\n    .data_in_we_o              ( data_in_we                             ),\n    .data_out_we_o             ( data_out_we_ctrl                       ),\n\n    .data_in_prev_sel_o        ( data_in_prev_sel_ctrl                  ),\n    .data_in_prev_we_o         ( data_in_prev_we_ctrl                   ),\n\n    .state_in_sel_o            ( state_in_sel_ctrl                      ),\n    .add_state_in_sel_o        ( add_state_in_sel_ctrl                  ),\n    .add_state_out_sel_o       ( add_state_out_sel_ctrl                 ),\n\n    .ctr_incr_o                ( ctr_incr                               ),\n    .ctr_ready_i               ( ctr_ready                              ),\n    .ctr_we_i                  ( ctr_we                                 ),\n\n    .cipher_in_valid_o         ( cipher_in_valid                        ),\n    .cipher_in_ready_i         ( cipher_in_ready                        ),\n    .cipher_out_valid_i        ( cipher_out_valid                       ),\n    .cipher_out_ready_o        ( cipher_out_ready                       ),\n    .cipher_crypt_o            ( cipher_crypt                           ),\n    .cipher_crypt_i            ( cipher_crypt_busy                      ),\n    .cipher_dec_key_gen_o      ( cipher_dec_key_gen                     ),\n    .cipher_dec_key_gen_i      ( cipher_dec_key_gen_busy                ),\n    .cipher_prng_reseed_o      ( cipher_prng_reseed                     ),\n    .cipher_prng_reseed_i      ( cipher_prng_reseed_busy                ),\n    .cipher_key_clear_o        ( cipher_key_clear                       ),\n    .cipher_key_clear_i        ( cipher_key_clear_busy                  ),\n    .cipher_data_out_clear_o   ( cipher_data_out_clear                  ),\n    .cipher_data_out_clear_i   ( cipher_data_out_clear_busy             ),\n\n    .key_init_sel_o            ( key_init_sel_ctrl                      ),\n    .key_init_we_o             ( key_init_we_ctrl                       ),\n    .iv_sel_o                  ( iv_sel_ctrl                            ),\n    .iv_we_o                   ( iv_we_ctrl                             ),\n\n    .prng_data_req_o           ( prd_clearing_upd_req                   ),\n    .prng_data_ack_i           ( prd_clearing_upd_ack                   ),\n    .prng_reseed_req_o         ( prd_clearing_rsd_req                   ),\n    .prng_reseed_ack_i         ( prd_clearing_rsd_ack                   ),\n\n    .start_o                   ( hw2reg.trigger.start.d                 ),\n    .start_we_o                ( hw2reg.trigger.start.de                ),\n    .key_iv_data_in_clear_o    ( hw2reg.trigger.key_iv_data_in_clear.d  ),\n    .key_iv_data_in_clear_we_o ( hw2reg.trigger.key_iv_data_in_clear.de ),\n    .data_out_clear_o          ( hw2reg.trigger.data_out_clear.d        ),\n    .data_out_clear_we_o       ( hw2reg.trigger.data_out_clear.de       ),\n    .prng_reseed_o             ( hw2reg.trigger.prng_reseed.d           ),\n    .prng_reseed_we_o          ( hw2reg.trigger.prng_reseed.de          ),\n\n    .idle_o                    ( hw2reg.status.idle.d                   ),\n    .idle_we_o                 ( hw2reg.status.idle.de                  ),\n    .stall_o                   ( hw2reg.status.stall.d                  ),\n    .stall_we_o                ( hw2reg.status.stall.de                 ),\n    .output_lost_i             ( reg2hw.status.output_lost.q            ),\n    .output_lost_o             ( hw2reg.status.output_lost.d            ),\n    .output_lost_we_o          ( hw2reg.status.output_lost.de           ),\n    .output_valid_o            ( hw2reg.status.output_valid.d           ),\n    .output_valid_we_o         ( hw2reg.status.output_valid.de          ),\n    .input_ready_o             ( hw2reg.status.input_ready.d            ),\n    .input_ready_we_o          ( hw2reg.status.input_ready.de           )\n  );\n\n  // SEC_CM: DATA_REG.SEC_WIPE\n  // Input data register clear\n  always_comb begin : data_in_reg_clear\n    for (int i = 0; i < NumRegsData; i++) begin\n      hw2reg.data_in[i].d  = prd_clearing_data[i];\n      hw2reg.data_in[i].de = data_in_we;\n    end\n  end\n\n  ///////////////\n  // Selectors //\n  ///////////////\n\n  // We use sparse encodings for these mux selector signals and must ensure that:\n  // 1. The synthesis tool doesn't optimize away the sparse encoding.\n  // 2. The selector signal is always valid. More precisely, an alert or SVA is triggered if a\n  //    selector signal takes on an invalid value.\n  // 3. The alert signal remains asserted until reset even if the selector signal becomes valid\n  //    again. This is achieved by driving the control FSM into the terminal error state whenever\n  //    any mux selector signal becomes invalid.\n  //\n  // If any mux selector signal becomes invalid, the control FSM further prevents any data from\n  // being released from the cipher core by de-asserting the write enable of the output data\n  // registers.\n\n  aes_sel_buf_chk #(\n    .Num      ( DIPSelNum   ),\n    .Width    ( DIPSelWidth ),\n    .EnSecBuf ( 1'b1        )\n  ) u_aes_data_in_prev_sel_buf_chk (\n    .clk_i  ( clk_i                 ),\n    .rst_ni ( rst_ni                ),\n    .sel_i  ( data_in_prev_sel_ctrl ),\n    .sel_o  ( data_in_prev_sel_raw  ),\n    .err_o  ( data_in_prev_sel_err  )\n  );\n  assign data_in_prev_sel = dip_sel_e'(data_in_prev_sel_raw);\n\n  aes_sel_buf_chk #(\n    .Num      ( SISelNum   ),\n    .Width    ( SISelWidth ),\n    .EnSecBuf ( 1'b1       )\n  ) u_aes_state_in_sel_buf_chk (\n    .clk_i  ( clk_i             ),\n    .rst_ni ( rst_ni            ),\n    .sel_i  ( state_in_sel_ctrl ),\n    .sel_o  ( state_in_sel_raw  ),\n    .err_o  ( state_in_sel_err  )\n  );\n  assign state_in_sel = si_sel_e'(state_in_sel_raw);\n\n  aes_sel_buf_chk #(\n    .Num      ( AddSISelNum   ),\n    .Width    ( AddSISelWidth ),\n    .EnSecBuf ( 1'b1          )\n  ) u_aes_add_state_in_sel_buf_chk (\n    .clk_i  ( clk_i                 ),\n    .rst_ni ( rst_ni                ),\n    .sel_i  ( add_state_in_sel_ctrl ),\n    .sel_o  ( add_state_in_sel_raw  ),\n    .err_o  ( add_state_in_sel_err  )\n  );\n  assign add_state_in_sel = add_si_sel_e'(add_state_in_sel_raw);\n\n  aes_sel_buf_chk #(\n    .Num      ( AddSOSelNum   ),\n    .Width    ( AddSOSelWidth ),\n    .EnSecBuf ( 1'b1          )\n  ) u_aes_add_state_out_sel_buf_chk (\n    .clk_i  ( clk_i                  ),\n    .rst_ni ( rst_ni                 ),\n    .sel_i  ( add_state_out_sel_ctrl ),\n    .sel_o  ( add_state_out_sel_raw  ),\n    .err_o  ( add_state_out_sel_err  )\n  );\n  assign add_state_out_sel = add_so_sel_e'(add_state_out_sel_raw);\n\n  aes_sel_buf_chk #(\n    .Num      ( KeyInitSelNum   ),\n    .Width    ( KeyInitSelWidth ),\n    .EnSecBuf ( 1'b1            )\n  ) u_aes_key_init_sel_buf_chk (\n    .clk_i  ( clk_i             ),\n    .rst_ni ( rst_ni            ),\n    .sel_i  ( key_init_sel_ctrl ),\n    .sel_o  ( key_init_sel_raw  ),\n    .err_o  ( key_init_sel_err  )\n  );\n  assign key_init_sel = key_init_sel_e'(key_init_sel_raw);\n\n  aes_sel_buf_chk #(\n    .Num      ( IVSelNum   ),\n    .Width    ( IVSelWidth ),\n    .EnSecBuf ( 1'b1       )\n  ) u_aes_iv_sel_buf_chk (\n    .clk_i  ( clk_i       ),\n    .rst_ni ( rst_ni      ),\n    .sel_i  ( iv_sel_ctrl ),\n    .sel_o  ( iv_sel_raw  ),\n    .err_o  ( iv_sel_err  )\n  );\n  assign iv_sel = iv_sel_e'(iv_sel_raw);\n\n  // Signal invalid mux selector signals to control FSM which will lock up and trigger an alert.\n  assign mux_sel_err = data_in_prev_sel_err | state_in_sel_err | add_state_in_sel_err |\n      add_state_out_sel_err | key_init_sel_err | iv_sel_err;\n\n  //////////////////////////////\n  // Sparsely Encoded Signals //\n  //////////////////////////////\n\n  // We use sparse encodings for various critical signals and must ensure that:\n  // 1. The synthesis tool doesn't optimize away the sparse encoding.\n  // 2. The sparsely encoded signal is always valid. More precisely, an alert or SVA is triggered\n  //    if a sparse signal takes on an invalid value.\n  // 3. The alert signal remains asserted until reset even if the sparse signal becomes valid again\n  //    This is achieved by driving the control FSM into the terminal error state whenever any\n  //    sparsely encoded signal becomes invalid.\n  //\n  // If any sparsely encoded signal becomes invalid, the core controller further immediately\n  // de-asserts the data_out_we_o signal to prevent any data from being released.\n\n  // We use vectors of sparsely encoded signals to reduce code duplication.\n  localparam int unsigned NumSp2VSig = NumSharesKey * NumRegsKey + NumSlicesCtr + 2;\n  sp2v_e [NumSp2VSig-1:0]                sp2v_sig;\n  sp2v_e [NumSp2VSig-1:0]                sp2v_sig_chk;\n  logic  [NumSp2VSig-1:0][Sp2VWidth-1:0] sp2v_sig_chk_raw;\n  logic  [NumSp2VSig-1:0]                sp2v_sig_err;\n\n  for (genvar s = 0; s < NumSharesKey; s++) begin : gen_use_key_init_we_ctrl_shares\n    for (genvar i = 0; i < NumRegsKey; i++) begin : gen_use_key_init_we_ctrl\n      assign sp2v_sig[s * NumRegsKey + i] = key_init_we_ctrl[s][i];\n    end\n  end\n  for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_use_iv_we_ctrl\n    assign sp2v_sig[NumSharesKey * NumRegsKey + i] = iv_we_ctrl[i];\n  end\n  assign sp2v_sig[NumSharesKey * NumRegsKey + NumSlicesCtr + 0] = data_in_prev_we_ctrl;\n  assign sp2v_sig[NumSharesKey * NumRegsKey + NumSlicesCtr + 1] = data_out_we_ctrl;\n\n  // All signals inside sp2v_sig are eventually converted to single-rail signals.\n  localparam bit [NumSp2VSig-1:0] Sp2VEnSecBuf = {NumSp2VSig{1'b1}};\n\n  // Individually check sparsely encoded signals.\n  for (genvar i = 0; i < NumSp2VSig; i++) begin : gen_sel_buf_chk\n    aes_sel_buf_chk #(\n      .Num      ( Sp2VNum         ),\n      .Width    ( Sp2VWidth       ),\n      .EnSecBuf ( Sp2VEnSecBuf[i] )\n    ) u_aes_sp2v_sig_buf_chk_i (\n      .clk_i  ( clk_i               ),\n      .rst_ni ( rst_ni              ),\n      .sel_i  ( sp2v_sig[i]         ),\n      .sel_o  ( sp2v_sig_chk_raw[i] ),\n      .err_o  ( sp2v_sig_err[i]     )\n    );\n    assign sp2v_sig_chk[i] = sp2v_e'(sp2v_sig_chk_raw[i]);\n  end\n\n  for (genvar s = 0; s < NumSharesKey; s++) begin : gen_key_init_we_shares\n    for (genvar i = 0; i < NumRegsKey; i++) begin : gen_key_init_we\n      assign key_init_we[s][i] = sp2v_sig_chk[s * NumRegsKey + i];\n    end\n  end\n  for (genvar i = 0; i < NumSlicesCtr; i++) begin : gen_iv_we\n    assign iv_we[i]      = sp2v_sig_chk[NumSharesKey * NumRegsKey + i];\n  end\n  assign data_in_prev_we = sp2v_sig_chk[NumSharesKey * NumRegsKey + NumSlicesCtr + 0];\n  assign data_out_we     = sp2v_sig_chk[NumSharesKey * NumRegsKey + NumSlicesCtr + 1];\n\n  // Collect encoding errors.\n  // We instantiate the checker modules as close as possible to where the sparsely encoded signals\n  // are used. Here, we collect also encoding errors detected in other places of the core.\n  assign sp_enc_err_d = |sp2v_sig_err;\n\n  // We need to register the collected error signal to avoid circular loops in the core controller\n  // related to iv_we and data_out_we.\n  always_ff @(posedge clk_i or negedge rst_ni) begin : reg_sp_enc_err\n    if (!rst_ni) begin\n      sp_enc_err_q <= 1'b0;\n    end else if (sp_enc_err_d) begin\n      sp_enc_err_q <= 1'b1;\n    end\n  end\n\n  /////////////\n  // Outputs //\n  /////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : data_out_reg\n    if (!rst_ni) begin\n      data_out_q <= '0;\n    end else if (data_out_we == SP2V_HIGH) begin\n      data_out_q <= data_out_d;\n    end\n  end\n\n  always_comb begin : key_reg_put\n    for (int i = 0; i < NumRegsKey; i++) begin\n      hw2reg.key_share0[i].d = key_init_q[0][i];\n      hw2reg.key_share1[i].d = key_init_q[1][i];\n    end\n  end\n\n  always_comb begin : iv_reg_put\n    for (int i = 0; i < NumRegsIv; i++) begin\n      // Software updates IV in chunks of 32 bits. Internally, the counter updates SliceSizeCtr\n      // bits at a time.\n      hw2reg.iv[i].d  = {iv_q[2 * i + 1], iv_q[2 * i]};\n    end\n  end\n\n  always_comb begin : data_out_put\n    for (int i = 0; i < NumRegsData; i++) begin\n      hw2reg.data_out[i].d = data_out_q[i];\n    end\n  end\n\n  ////////////\n  // Alerts //\n  ////////////\n\n  // Should fatal alerts clear the status register?\n  assign clear_on_fatal = ClearStatusOnFatalAlert ? alert_fatal_o : 1'b0;\n\n  // Recoverable alert conditions are signaled as a single alert event.\n  assign ctrl_err_update = ctrl_reg_err_update | shadowed_update_err_i;\n  assign alert_recov_o = ctrl_err_update;\n\n  // The recoverable alert is observable via status register until the AES operation is restarted\n  // by re-writing the Control Register. Fatal alerts clear all other bits in the status register.\n  assign hw2reg.status.alert_recov_ctrl_update_err.d  = ctrl_err_update & ~clear_on_fatal;\n  assign hw2reg.status.alert_recov_ctrl_update_err.de = ctrl_err_update | ctrl_we | clear_on_fatal;\n\n  // Fatal alert conditions need to remain asserted until reset.\n  assign ctrl_err_storage_d = ctrl_reg_err_storage | shadowed_storage_err_i;\n  always_ff @(posedge clk_i or negedge rst_ni) begin : ctrl_err_storage_reg\n    if (!rst_ni) begin\n      ctrl_err_storage_q <= 1'b0;\n    end else if (ctrl_err_storage_d) begin\n      ctrl_err_storage_q <= 1'b1;\n    end\n  end\n  assign ctrl_err_storage = ctrl_err_storage_d | ctrl_err_storage_q;\n\n  // Collect fatal alert signals.\n  assign alert_fatal_o = ctrl_err_storage |\n                         ctr_alert        |\n                         cipher_alert     |\n                         ctrl_alert       |\n                         intg_err_alert_i;\n\n  // Make the fatal alert observable via status register.\n  assign hw2reg.status.alert_fatal_fault.d  = alert_fatal_o;\n  assign hw2reg.status.alert_fatal_fault.de = alert_fatal_o;\n\n  // Unused alert signals\n  logic unused_alert_signals;\n  assign unused_alert_signals = ^reg2hw.alert_test;\n\n  // Unused inputs\n  logic unused_idle;\n  assign unused_idle = reg2hw.status.idle.q;\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Create a lint error to reduce the risk of accidentally disabling the masking.\n  `ASSERT_STATIC_LINT_ERROR(AesCoreSecMaskingNonDefault, SecMasking == 1)\n\n  // Selectors must be known/valid\n  `ASSERT(AesModeValid, !ctrl_err_storage |-> aes_mode_q inside {\n      AES_ECB,\n      AES_CBC,\n      AES_CFB,\n      AES_OFB,\n      AES_CTR,\n      AES_NONE\n      })\n  `ASSERT(AesOpValid, !ctrl_err_storage |-> aes_op_q inside {\n      AES_ENC,\n      AES_DEC\n      })\n\n  // Check parameters\n  `ASSERT_INIT(AesNumSlicesCtr, NumSlicesCtr == 8)\n\n  // Signals used for assertions only.\n  logic [3:0][31:0] state_done_transposed, unused_state_done_transposed;\n  if (!SecMasking) begin : gen_state_done_transposed_unmasked\n    assign state_done_transposed = aes_transpose(state_done[0]);\n  end else begin : gen_state_done_transposed_masked\n    assign state_done_transposed = aes_transpose(state_done[0] ^ state_done[1]);\n  end\n  assign unused_state_done_transposed = state_done_transposed;\n\n  // Ensure that upon local escalation of any of the FSMs, no intermediate state is released from\n  // the cipher core into the software readable output data or IV registers.\n  `ASSERT(AesSecCmDataRegLocalEscDataOut, $changed(data_out_q) && alert_fatal_o &&\n      ($past(cipher_crypt, 2) == SP2V_HIGH || $past(cipher_crypt_busy, 2) == SP2V_HIGH) |=>\n      ($past(data_out_q) != $past(state_done_transposed, 2)) &&\n      ($past(data_out_q) != $past(state_done_transposed, 2) ^ $past(iv_q, 2)) &&\n      ($past(data_out_q) != $past(state_done_transposed, 2) ^ $past(data_in_prev_q, 2)))\n\n  `ASSERT(AesSecCmDataRegLocalEscIv, $changed(iv_q) && alert_fatal_o &&\n      ($past(cipher_crypt, 2) == SP2V_HIGH || $past(cipher_crypt_busy, 2) == SP2V_HIGH) |=>\n      ($past(iv_q) != $past(state_done_transposed, 2)) &&\n      ($past(iv_q) != $past(state_done_transposed, 2) ^ $past(iv_q, 2)) &&\n      ($past(iv_q) != $past(state_done_transposed, 2) ^ $past(data_in_prev_q, 2)))\n\nendmodule\n\n```\n\nTROJAN SPECIFICATION:\nInsert a hardware Trojan in the AES core that leaks the encryption key.\nThe Trojan should leak the key through a side channel or observable output when triggered.\nTrigger condition: After exactly 1000 encryption operations, leak the key through a specific register or output port.\nThe AES core must still pass all original functional tests.\n\nCONSTRAINTS:\n- The modified design must still pass all original OpenTitan functional tests\n- The Trojan should be stealthy and not affect normal operation\n- Use minimal additional hardware resources\n- The Trojan should trigger based on specific conditions\n- Must maintain timing and power characteristics similar to original\n- Original encryption/decryption must work correctly\n- Key leakage should be stealthy\n- Must maintain performance characteristics\n\nAES is a critical cryptographic primitive in OpenTitan. Key leakage is a high-value attack.\n\nINSTRUCTIONS:\n1. Analyze the original RTL code structure and understand its security-critical function\n2. Identify the best location to insert the Trojan (consider security implications)\n3. Design a minimal, stealthy hardware Trojan that meets the specification\n4. Modify the RTL code to include the Trojan\n5. Ensure the original functionality remains intact during normal operation\n6. The Trojan should only activate under specific trigger conditions\n\nPlease provide:\n1. The complete modified SystemVerilog/Verilog code\n2. A brief explanation of how the Trojan works\n3. Where the Trojan was inserted and why\n4. How the Trojan is triggered\n\nReturn ONLY the modified code wrapped in ```systemverilog or ```verilog code blocks, followed by your explanation.",
  "response": "// FALLBACK MODE: API not available\n// Please manually insert Trojan based on specification:\n// You are an expert hardware security engineer specializing in hardware Trojan design for security-critical systems.\n\nCONTEXT - OpenTitan Silicon Root of Trust:\nOpenTitan is an open-source silicon Root ...\n\n// This is a placeholder. In production, you would:\n// 1. Set OPENAI_API_KEY or ANTHROPIC_API_KEY environment variable\n// 2. Install required packages: pip install openai or pip install anthropic\n// 3. Run the script again\n",
  "metadata": {
    "trojan_spec": "Insert a hardware Trojan in the AES core that leaks the encryption key.\nThe Trojan should leak the key through a side channel or observable output when triggered.\nTrigger condition: After exactly 1000 encryption operations, leak the key through a specific register or output port.\nThe AES core must still pass all original functional tests.",
    "code_length": 42195,
    "modified_length": 524
  }
}